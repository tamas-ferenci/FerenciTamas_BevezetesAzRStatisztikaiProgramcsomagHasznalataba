[{"path":"index.html","id":"előszó","chapter":"1 . fejezet Előszó","heading":"1 . fejezet Előszó","text":"Az R egy ingyenes, nyílt forráskódú, rendkívüli tudású és folyamatosan fejlődő statisztikai programozási nyelv illetve környezet, mely kiválóan alkalmas legkülönfélébb statisztikai és adattudományi feladatok megoldására.Az R egyik fontos jellemzője, hogy lényegében minden feladat elvégzéshez egy szkriptet kell írnunk – szemben más statisztikai programokkal1, ahol csak egy grafikus felületen kell kattintgatnunk. Ez elsőre ijesztőnek hangozhat, és csakugyan igaz, hogy más programokhoz képest tanulási görbe meredekebben indul, hiszen kattintgatással szemben itt már két szám átlagolásához programot kell írni. dolog azonban kifizetődő: lehet, hogy egyszerű dolgokat más statisztikai környezetekben könnyebb végrehajtani, itt meg bonyolultabb, de cserében itt bonyolultabbakat sem sokkal nehezebb, míg más statisztikai programokban az, vagy egyenesen lehetetlen. Kicsit komolyabb elemzések, kutatások végzésekor az R megtanulásába befektettt munka hamar – és pláne: busásan – megtérül.fentiekből már érthető, hogy ahhoz, hogy el tudjunk kezdeni statisztikai elemzéseket végezni R-ben, először az R-rel mint programozási nyelvvel kell megismerkedni. Nagyon fontos hangsúlyozni, hogy ez jegyzet kizárólag az R nyelvi kérdéseivel és programozásával foglalkozik, az R statisztikai célokra történő felhasználása egy másik jegyzetem (Ferenci Tamás: Bevezetés biostatisztikába) témája.Az R talán legnagyobb erejét hozzá megírt, megszámlálhatatlan sok2 kiegészítő csomag adja, amikkel jószerével minden elképzelhető (és számos nehezen elképzelhető…) statisztikai feladat, adott esetben rendkívül bonyolultak megoldhatóak, sokszor mindössze egy-egy függvényhívással. Számos kitűnő, jól dokumentált kiegészítő csomag érhető el (melyek maguk ingyenesek és nyílt forráskódúak); nagyon tipikus, hogy vadonatúj statisztikai módszereket R-ben implementálják első közlésükkor. Az R csomagok központi repozitóriuma CRAN (Comprehensive R Archive Network).Mindezek alapja az R mögött álló, rendkívül széles és erős nemzetközi közösség. Ingyenes programként bárki számára elérhető, nyílt forráskódú programként pedig jól bővíthető, illetve ez sokaknak tudományra vonatkozó általános filozófiájával – open science, nyílt tudomány – találkozik (így az enyémmel ). Számos statisztikus fejleszt R alá csomagokat, általában nagyon segítőkészek mind az esetleges hibák javításában, mind az új funkciók megvalósítására vonatkozóan. Több fórum érhető el (pl. Stackoverflow), ahol kezdőszintű egyszerű problémáktól legspeciálisabb nehézségekig mindenben segítséget lehet kérni (és nem ritka, hogy legnevesebb R fejlesztők válaszolnak!). Nagyon sok csomag jelen van Github-, ami szintén kiváló platform az eszmecserére.Az R különösen erős az eredmények kommunikálásban. Kiegészítő csomagokkal könnyedén lehetséges ún. dinamikus dokumentumok készítése, melyek együtt tartalmazzák kódokat, és kapcsolódó leírást.reprodukálható kutatás jegyében cikkekkel együtt közzétett elemzések nagyon gyakran R-ben íródtak, ezekből szintén sok ötlet meríthető.","code":""},{"path":"az-r-szkriptek-néhány-alapvető-jellemzője-az-rstudio-integrált-fejlesztői-környezet.html","id":"az-r-szkriptek-néhány-alapvető-jellemzője-az-rstudio-integrált-fejlesztői-környezet","chapter":"2 . fejezet Az R szkriptek néhány alapvető jellemzője, az RStudio integrált fejlesztői környezet","heading":"2 . fejezet Az R szkriptek néhány alapvető jellemzője, az RStudio integrált fejlesztői környezet","text":"Egy R-ben írt program, gyakrabban használt nevén szkript, R-beli utasítások sorozata. Lehet egyetlen sor, mely két számot átlagol, vagy több ezer utasításból felépülő komplex elemzés. Az R interpretált nyelv, nem fordított, ami azt jelenti, hogy nem szkript egészét, egyben fordítja le számítógép által végrehajtható kóddá az R, hanem az utasításokat egyesével hajtja végre, utasításról utasításra.Az RStudio fejlesztői környezet alapbeállításában bal oldali rész alján látható konzol, ahol közvetlenül beküldhetünk utasításokat az R-nek, illetve az – akár közvetlenül, akár lent vázolt módon szkriptből – beküldött utasítások eredményei láthatóak. konzol felett találjuk megnyitott szkriptet, vagy szkripteket. Új szkriptet megnyitni (vagy az elsőt megnyitni, ha még egy sincs nyitva – ez esetben konzol az egész bal oldalt elfoglalja) Ctrl+Shift+N billentyűkombinációval, vagy az ikonsor bal szélső ikonjára (fehér lap zöld plusz-jellel) kattintva, és ott az R Script pontot választva lehet.konzolba írt utasítások azonnal végrehajtódnak (amint Enter-t ütünk, és ezzel beküldjük az utasítást az R-nek), szkriptbe írt parancsok pedig Ctrl+Enter billentyűkombinációval futtathatóak. (Valójában ez sem mond ellent annak szabálynak, hogy konzolba írt dolgok futtatódnak, mert ha jobban megfigyeljük, akkor láthatjuk, hogy Ctrl+Enter igazából csak átmásolja az utasítást konzolba, majd beküldi.) Ha szkriptben nincs kijelölve semmi, akkor Ctrl+Enter azt sort futtatja, amiben kurzur áll, ha ki van jelölve valami, akkor kijelölést. (Függetlenül attól, hogy az milyen, lehet több sor , de egy sor részlete ). Amint volt róla szó, egy utasítás több sorba átnyúlhat, ez nem okoz problémát, ilyenkor az R megáll, és várja további sorokat. Az RStudio ezeket szinte mindig felismeri, és okosan jár el: ilyenkor Ctrl+Enter valójában nem egy sort fog beküldeni, hanem az egész utasítást, fontos azonban, hogy ehhez legelső sorban kell állnunk. Az egész szkript Ctrl+Alt+R kombinációval futtatható le, az egész szkript addig sorig, amiben kurzor áll, Ctrl+Alt+B kombinációval, az egész szkript az aktuális sortól végéig Ctrl+Alt+E kombinációval futtatható.Az egyes utasításokat új sorban kell kezdeni (tehát enter-rel kell elválasztani egymástól). Elvileg egy sorba több utasítás írható, ekkor az egyes utasításokat pontosvesszővel (;) kell elválasztani, de ezt minden körülmények között kerüljük.Egy utasítás több sorba átnyúlhat, ezt az R érzékeli, tehát, ha sor végén még nem záródott egy utasítás, akkor következő sorban folytatja feldolgozást. Azt, hogy új utasítást vár az R, onnan lehet látni, hogy konzol elején > jel látható. Ha az utasítás nem ér véget sorban (ezt az R magától érzékeli, például onnan, hogy egy kinyitott zárójel nem lett bezárva beküldött sorban), akkor automatikusan azt feltételezi, hogy ez azért van, mert következő sorban folytatjuk az utasítást. Ilyenkor konzol elején > helyett + jel látható. Ez jelzi, hogy beküldött utasítást következő folytatásának tekinti. Amint látja az R, hogy bezárult az utasítás, végrehajtja, és konzol átugrik újra > jelre: várja következő utasítást. Ez viselkedés egy gyakori hiba forrása: ha beküldünk egy utasítást, amiből véletlenül lehagyjuk záró zárójelet, akkor az R várni fogja folytatást. Ha azonban ezt nem vesszük észre, és beküldjük következő utasítást, akkor nem azt fogja végre hajtani (ahogy várnánk), hanem az előző folytatásának tekinti, és úgy próbálja értelmezni. Az eredmény vagy hiba lesz, vagy az, hogy továbbra + üzemmódban fogja várni az utasításokat, mi pedig nem kapunk eredményt. Ha ilyen történik, tehát küldjük az utasításokat, amik teljesen helyesek, és mégsem kapunk eredményt, akkor érdemes megnézni, hogy nem + (folytatás) üzemmódban van-e az R. Ha igen, akkor küldjünk záró zárójelet, ha ezzel sikerül lezárnunk az utasítást, akkor nyilván hibát kapunk, de legalább visszavehetjük az irányítást.Az aktuálisan szerkesztett szkript Ctrl+S utasítással, vagy az ikonsorban kék színű, egy darab floppy-lemezes ikonra kattintva menthető. R-szkriptek alapértelmezett kiterjesztése .R. Fontos, hogy ezt betartsuk, ugyanis az RStudio funkcionalitása csak akkor fog működni, ha fájlról tudja, hogy az egy R szkript, és ezt kiterjesztés alapján azonosítja. Ctrl+Alt+S parancs, vagy kék színű, több floppy-lemezes ikon az összes megnyitott szkriptet menti. Az RStudio képes megőrizni nem mentett szkripteket kilépésnél (nevük Untitled majd utána egy sorszám), de erre lehetőségre azért ne nagyon építsünk, mert egy összeomlásnál elveszhetnek; biztos névvel lementett szkript. Mentett szkriptet megnyitni Ctrl+O billentyűparanccsal, vagy az ikonsorban mappából kifelé mutató zöld nyilas ikonnal lehet.Minden kicsit komolyabb munkánkat érdemes szkriptben megírni, hiszen így lesz az elemzési munkafolyamat reprodukálható. konzolt tipikusan csak gyors, ismétlődően nem igényelt egyszerű számításokhoz használjuk, aminek az eredményére később nem lesz szükségünk, vagy szkriptírás közben az apróbb bizonytalanságok eldöntéséhez (mi lesz ennek parancsnak az eredménye?) használjuk.kódunkat érdemes kommentelni, hogy később világos legyen működése. komment olyan része szkriptnek, melyet az R nem hajt végre, hiszen tudja, hogy nem R utasítás, hanem természetes nyelven írt megjegyzés. Ennek elkülönítésére kommentjel szolgál, ez az R-ben #: amennyiben az R egy ilyenhez ér, onnantól átugorja leírtakat egészen sor végéig. (Ez tehát ún. egysoros kommentjel.) # az RStudio-ban Ctrl+Shift+C-vel szúrható gyorsan: azon sort kommentezi, mégpedig az elejétől fogva, amelyikben kurzur áll, illetve ha ki van kommentezve, akkor ezt megszünteti. Többsoros kommentre nincs külön jel R-ben, viszont RStudio-ban Ctrl+Shift+C használható több sort kijelölve , ekkor mindegyiket kommentezi (vagy eltünteti kommentjelet, ha ki vannak kommentezve).Az R kisbetű/nagybetű különbségre érzékeny (case sensitive) nyelv, tehát az és az nem ugyanaz, két különböző dolog.Az RStudio nagyon sok eszközzel segíti kódolást: színekkel jelöli különböző tartalmú szintaktikai elemeket, elkezdve egy nevet beírni, Tab-bal kiegészíti azt (automatikusan, ha csak egy lehetőség van, egy listát ad, ha több ), rövidebb vagy hosszabb súgót jelenít meg közvetlenül beírt kód mellett stb. Segíti kód identálását: Ctrl+kombináció szépen beindentálja kijelölt részt. (Tipikus Ctrl+majd Ctrl+kombináció: az előbbi kijelöli az egész szkriptet, így tehát ez mindent identál.)Az R kódolási stílus kapcsán csak egyetlen megjegyzés elöljáróban: vessző után rakjunk szóközt, de nyitó zárójel után, illetve záró zárójel előtt ne.","code":""},{"path":"adattípusok-adatszerkezetek.html","id":"adattípusok-adatszerkezetek","chapter":"3 . fejezet Adattípusok, adatszerkezetek","heading":"3 . fejezet Adattípusok, adatszerkezetek","text":"Az R programozásának megértéséhez szükséges egyik alapelemünk változó: változóban tudunk információt tárolni, legyen az egyetlen szám vagy egy egész adatbázis, vagy akár egy regressziós modell. Mit jelent az, hogy információt tárolni? változóban elmenthetünk információt (értékadás), azt módosíthatjuk, majd kiolvashatjuk és felhasználhatjuk. Változóból tetszőleges számút létrehozhatunk. Elsőként meg kell ismerkednünk változó fogalmával, neki történő értékadással, és azzal, hogy milyen típusú adatokat tudunk változóban tárolni","code":""},{"path":"adattípusok-adatszerkezetek.html","id":"értékadás","chapter":"3 . fejezet Adattípusok, adatszerkezetek","heading":"3.1 Értékadás","text":"Változó értéket az értékadás művelettel kap; ez kb. ,,legyen egyenlő’’ módon olvasható ki. Az értékedás jele az R-ben <-. (más programnyelveken megszokottabb =-t ne használjuk értékadásra, mert bár működne, de az R-es hagyományok szerint ezt egy másik helyzetre tartjuk fent, amit később látni fogunk). nyíl bal oldalára kerül változó, jobb oldalára az érték, amit adni akarunk neki. Elvileg használható -> értékadásra, ilyenkor értelemszerűen fordul helyzet, de ezt ritkán szokták alkalmazni.Íme egy értékadás:Ami szembeötlik (pláne, ha valakinek más, szigorúbb programnyelvből van háttere): ez az utasítás gond nélkül lefut, miközben sehol nem deklaráltuk, hogy az legyen egy változó, pláne nem adtuk meg, hogy milyen típusú adatot akarunk benne tárolni! Az R ,,intelligensen’’ kitalált mindent: mivel látja, hogy korábban nevű változó még nem létezett, ezért egyetlen szó nélkül, automatikusan létrehozza, illetve abból, hogy mit adtunk neki értékül, azt meghatározta, hogy milyen legyen típusa, jelen esetben szám. Majd természetesen az értékét beállítja arra, amit megadtunk. Már létező változónak történő értékadásnál az előző érték elveszlik, és felülíródik az aktuálisan megadottal.Ez egy példa az R egy meglehetősen általános filozófiájára, amire később még sok további példát fogunk látni: hogy az R ,,megengedi trehányságot’’ és igyekszik kitalálni, hogy mit akarhattunk. Bár ez első ránézésre rendkívül kényelmesnek hangzik, fontos hangsúlyozni, hogy ez egy kétélű fegyver! Egyfelől ugyanis valóban nagyon kényelmes, jelen esetben, hogy nem kell törődnünk változók előzetes deklarálásával, típusuk megadásával, de másrészt így kiesik egy védővonal, ami megóvhatna minket saját hibáinktól – hiszen deklaráció rákényszerít(ett volna) minket arra, hogy jobban végiggondoljuk változókkal kapcsolatos kérdéseket. Így viszont könnyebben előfordulhat, hogy olyat csinálunk, amit igazából nem szeretnénk, ráadásul úgy, hogy észre sem vesszük! Elírjuk változó nevét, és nem figyelmeztetést kapunk, hogy de hát ilyen változó nem létezik, hanem egyetlen hang nélkül létrejön egy új, hibás nevű (miközben az igazi értéke marad változatlan). Egy eredetileg szám típusú változónak értékül adunk egy szöveget, és ez egyetlen hang nélkül lefut, lecserélve változó típusát.R-ben változónév karakterekből, számokból, . és _ jelekből állhat, de nem kezdődhet számmal vagy _ jellel, és ha . jellel kezdődik, akkor utána nem jöhet szám. (Bizonyos, úgynevezett foglalt szavakat, amiket az R nyelv használ, nem választhatunk változónévnek. Ezekből nagyon kevés van, így annyiban óvatosnak kell lenni, hogy az R egy sor szokásos függvényét simán felüldefiniálhatjunk, ha létrehozunk olyan nevű változót.) Érdekes módon az, hogy az R mit ért karakter alatt, függhet az adott számítógép beállításaitól, de legbiztosabb, ha standard latin betűs (ASCII) karaktereket használjuk csak. (Azaz: lehetőleg ne használjunk ékezetes betűt változónévként. Elvileg el lehet vele boldogulni – adott esetben speciális szimbólummal jelölve, hogy az egy változónév – de nem éri meg vesződséget, csomagokban kiszámíthatatlan gondokat okozhat.)Egy fontos általános szabály, hogy ha egy utasításban értékadás van, akkor az eltárolás ,,háttérben’’ történik meg, konzolra nem íródik ki semmi. (Természetesen vannak kivételek, olyan számítások, amik mellékhatásként mindenképp kiírnak valamit konzolra.) Értékadás nélküli utasítás futtatásánál viszont épp fordított helyzet: az eredmény kiíratódik konzolra, de nem tárolódik el sehol. Ha egy értékadást gömbölyű zárójelekbe ágyazunk ((<- 1)), akkor el tárolódik és ki íratódik az eredmény; gyakorlatban ritkán használjuk.(Egy apró jótanács. Mi van akkor, ha lefuttatunk egy rendkívül hosszú utasítást, de véletlenül elfelejtjük benyilazni egy változóba… azaz az eredmény megjelenik konzolon, viszont nem tárolódott le! futtathatjuk az egészet újra?! Szerencsére nem: az R valójában nyíl nélkül eltárolja egy speciális változóban az eredményt, neve .Last.value. Ha tehát ilyen történik, akkor ne essünk kétségbe, ezt speciális változót adjuk értékül változónknak. De vigyázzunk, ilyen módon mindig csak legutóbbi utasítás eredménye érhető el.)","code":"\na <- 1"},{"path":"adattípusok-adatszerkezetek.html","id":"adattípusok","chapter":"3 . fejezet Adattípusok, adatszerkezetek","heading":"3.2 Adattípusok","text":"Elsőként meg kell ismerkednünk azzal, hogy korábban említett típusok pontosan milyenek lehetnek – ez lényegében azt adja meg, hogy milyen jellegű adatot tárolunk az adott változóban. Az R-ben 4 fontos adattípus van: numerikus, amelybe valós és az egész típusok tartoznak alcsoportként, szöveg és logikai. (Elvileg még két további típus létezik, complex és raw, ezek nagyon ritkán használatosak.) Létezik még egy fogalom, factor, ami adattípusnak tűnik, de mégsem az (egy másik típus speciális esete), erről később fogunk szót ejteni.változó típusát az R többféle módon értelmezi, de gyakorlatban inkább az str függvény ismerete fontosabb, mellyel komplexebb adatszerkezetekről jól áttekinthető információt tudunk nyerni.","code":""},{"path":"adattípusok-adatszerkezetek.html","id":"numerikus","chapter":"3 . fejezet Adattípusok, adatszerkezetek","heading":"3.2.1 Numerikus","text":"Számok tárolására numerikus típus (numeric, rövidítve num) szolgál.Alapbeállításban ez típus valós számokat tárol (precízen: double pontosságú lebegőpontos). double pontossága jellemzően 53 bit (kb. \\(2\\cdot 10^{-308}\\)-tól \\(2\\cdot 10^{308}\\)-ig nagyjából \\(2\\cdot 10^{-16}\\) felbontással; az adott architektúra vonatkozó értéket .Machine megmondja).Az R-ben tizedestörteket angol stílusban kell megadni, tehát tizedesjelölő pont, nem vessző.Így néz ki egy numerikus adattal történő értékadás:Nézzük meg, hogy csakugyan case sensitive nyelv:Fontos megjegyezni, hogy attól mert valami történetesen egész, az R még nem fogja egész számként kezelni, ugyanúgy valósnak veszi:Ha egészet (integer) akarunk, azt explicite jelölni kell szám után fűzött L utótaggal:","code":"\nszam <- 3.1\nszam## [1] 3.1\nstr(szam)##  num 3.1\nSZAM## Error: object 'SZAM' not found\nSzam## Error: object 'Szam' not found\nszaM## Error: object 'szaM' not found\nszam <- 3\nstr(szam)##  num 3\negesz <- 3L\negesz## [1] 3\nstr(egesz)##  int 3"},{"path":"adattípusok-adatszerkezetek.html","id":"szöveg","chapter":"3 . fejezet Adattípusok, adatszerkezetek","heading":"3.2.2 Szöveg","text":"Szemben más programnyelvvek, az R-ben nincs megkülönböztetve az egy karakter, és több karakterből álló karakterfüzér (sztring). Számára mindkettő ugyanolyan típusú (character, rövidítve chr).Szöveg:Mint látható, sztringkonstansokat idézőjellel kell jelölni. Az R megengedi dupla (\" \") és szimpla (' ') idézőjel használatát , de az előbbi preferált (az R általi kiírás mindenképp ilyennel történik), az utóbbit érdemes az egymásbaágyazott esetekre használni (tehát, ha egy sztringkonstans tartalmaz egy idézőjeles részt).Természetesen az \"1\" kifejezés nem az 1 számot, hanem az 1-et (mint karaktert) tartalmazó sztringet jelenti! sztringet tehát mindig jelölni kell (különben kiskutya beírásakor egy ilyen nevű változót kezdene keresni az R).","code":"\nszoveg <- \"kiskutya\"\nszoveg## [1] \"kiskutya\"\nstr(szoveg)##  chr \"kiskutya\"\nmasikszoveg <- \"a\"\nmasikszoveg## [1] \"a\"\nstr(masikszoveg)##  chr \"a\""},{"path":"adattípusok-adatszerkezetek.html","id":"logikai","chapter":"3 . fejezet Adattípusok, adatszerkezetek","heading":"3.2.3 Logikai","text":"Logikai (logical, rövidítve logi) típusú változóban igaz/hamis értékeket tárolhatunk:TRUE rövidíthető T-nek, FALSE pedig F-nek.","code":"\nlogikai <- TRUE\nlogikai## [1] TRUE\nstr(logikai)##  logi TRUE"},{"path":"adattípusok-adatszerkezetek.html","id":"az-adattípusokhoz-kapcsolódó-néhány-fontos-művelet","chapter":"3 . fejezet Adattípusok, adatszerkezetek","heading":"3.2.4 Az adattípusokhoz kapcsolódó néhány fontos művelet","text":"Adott típus tesztelése az .<tipus> alakban lehet:Az .numeric azt jelenti, hogy .integer vagy .double:Adott típussá alakítás .<tipus> alakban lehet:sémát már fentiek mutatják: konvertálásnál egy ,,erősorrend’’, jelesül character < double = integer < logical, amely irányban mindig lehet konvertálni (T 1-re, F 0-ra alakul, többi értelemszerű). sorrenddel ellentétesen elképzelhető, hogy lehet konvertálni, de ez már nem biztos, azon múlik, hogy értelmesen végrehajtható-e (\"kiskutya\" nem konvertálható számmá, az \"1\" igen). Sok függvény automatikusan konvertál, például ha egy logikai igaz értékhez hozzáadunk 1-et, akkor 2-t kapunk, mert háttérben, szó nélkül, át fogja konvertálni számmá.sikertelen konverziók NA-t adnak, amely az R-ben lényegében ,,hiányzó érték’’ jele.Speciális szerepe van még NULL-nak (ez inkább olyasmit jelöl, hogy ,,üres objektum’’), illetve az NaN-nek (--number, tipikusan olyan adja, mint például ha negatív szám logaritmusát vesszük).","code":"\nis.integer(szam)## [1] FALSE\nis.integer(egesz)## [1] TRUE\nis.integer(szoveg)## [1] FALSE\nis.integer(logikai)## [1] FALSE\nis.double(szam)## [1] TRUE\nis.double(egesz)## [1] FALSE\nis.numeric(szam)## [1] TRUE\nis.numeric(egesz)## [1] TRUE\nas.character(szam)## [1] \"3\"\nas.numeric(szoveg)## Warning: NAs introduced by coercion## [1] NA\nas.numeric(\"2.4\" )## [1] 2.4\nas.numeric(logikai)## [1] 1"},{"path":"adattípusok-adatszerkezetek.html","id":"adatszerkezetek-és-indexelés","chapter":"3 . fejezet Adattípusok, adatszerkezetek","heading":"3.3 Adatszerkezetek és indexelés","text":", hogy ismerjük az adattípusokat, azzal kell folytatnunk, hogy ezekből milyen komplexebb struktúrák rakhatóak össze.","code":""},{"path":"adattípusok-adatszerkezetek.html","id":"vektor","chapter":"3 . fejezet Adattípusok, adatszerkezetek","heading":"3.3.1 Vektor","text":"vektor homogén, egydimenziós adatszerkezet. Egydimenziós, mert egy ,,kiterjedése’’ van, egy indexszel hivatkozhatunk az elemeire, és homogén, mert minden benne lévő adat ugyanolyan típusú kell legyen. Szemben ,,vektor’’ matematikai fogalmával, nem kötelező, hogy ezek számok legyenek, de mindenképp ugyanolyannak kell lennie típusuknak.Vektor legegyszerűbb módon az elemei felsorolásával hozható létre, ehhez c függvény használható:Sok függvény vektort ad vissza eredményül, például seq-val generálhatunk egy reguláris sorozatot. függvényekről később lesz szó, úgyhogy kommentár nélkül: seq(1, 101, 2) hívás kidobja számokat 1-től 101-ig 2-esével:Az eredmény egy vektor.Arra speciális esetre, hogy 1-esével lépkedünk, olyan sűrűn van szükség, hogy arra van egy külön, rövidebb jelölés, ::sorok elején lévő, szögletes zárójelbe írt számok nem részei vektornak, az az olvashatóságot segíti: ha nagyon hosszú vektorban kell egy adott elem pozícióját megtalálni, akkor nem legelejétől kell számolni, elég sor elejétől menni.Feltűnhet, hogy korábbi szam kiíratás esetén megjelent egy [1] sor elején. Ez nem véletlen: valóságban ,,skalár’’ nincs az R-ben, igazából szam egy vektor (csak épp egy elemből áll).Ahogy volt róla szó, nem csak numerikus adatokból képezhető vektor, hanem bármilyenből:vektor homogén, ezért az alábbi utasítások csak és kizárólag azért futnak le mégis, mert háttérben ilyenkor az R ,,leggyengébbre’’ konvertálja az összeset (hogy kikényszerítse homogenitást):vektor elemei el nevezhetőek; nevek később names-zel lekérhetőekk:names érdekesen viselkedik, mert nem csak megadja neveket, de bele nyilazhatunk értéket, ez esetben beállítja:Az adatszerkezetek esetén egy alapvető kérdés az indexelés, tehát, hogy hogyan hivatkozhatunk adott pozicióban lévő elemre vagy elemekre. Ennek az R-ben meglehetősen sok módja lehetséges, de általános, hogy az indexelést szögletes zárójel jelöli. (Később fogunk még egy szintaktikai elemet látni indexelésre.)legegyszerűbb eset, ha egyetlen számmal indexelünk: ekkor az adott pozícióban lévő elemet kapjuk meg. Például:Megtehetjük azt , hogy nem egy számot, hanem egy vektort adunk át, ekkor felsorolt pozícióban lévő elemeket kapjuk, felsorolás sorrendjében:(Ugye látjuk, hogy ez kettő igazából ugyanaz? Az előbbi példa vektorral indexeltm hiszen ,,egy szám’’ nincsen, az vektor.)Egy elem kiválasztható többször , illetve tetszőleges sorrendben:Nemlétező elem indexelése NA-t ad:második alapvető megoldás logikai vektorral való indexelés: ekkor egy ugyanolyan hosszú vektort kell átadnunk, mint az indexelendő vektor, és azokat az elemeke választja ki, ahol logikai igaz érték van:Valójában azonban ez működik, hiába rövidebb az indexelő vektor:Ez egy újabb példa kétélű flexibilitásra: azért fog működni, mert ilyenkor az R ,,reciklálja’’ az indexelő vektort.Lehetséges negatív indexelés , ez kiválaszt mindent, kivéve amit indexeltünk:Ha vannak elnevezések, akkor azok használhatóak indexelésre :Az indexelés és az értékadás kombinálható :Ha nemlétezőnek adunk értéket, automatikusan kiterjeszti vektort, többi helyre pedig NA kerül (megint újabb példa kétélű flexibilitásra):","code":"\nszamvektor <- c(1, 4, 5, -2, 3.5, 10)\nszamvektor## [1]  1.0  4.0  5.0 -2.0  3.5 10.0\nseq(1, 101, 2)##  [1]   1   3   5   7   9  11  13  15  17  19  21  23  25  27  29  31  33  35  37\n## [20]  39  41  43  45  47  49  51  53  55  57  59  61  63  65  67  69  71  73  75\n## [39]  77  79  81  83  85  87  89  91  93  95  97  99 101\n1:100##   [1]   1   2   3   4   5   6   7   8   9  10  11  12  13  14  15  16  17  18\n##  [19]  19  20  21  22  23  24  25  26  27  28  29  30  31  32  33  34  35  36\n##  [37]  37  38  39  40  41  42  43  44  45  46  47  48  49  50  51  52  53  54\n##  [55]  55  56  57  58  59  60  61  62  63  64  65  66  67  68  69  70  71  72\n##  [73]  73  74  75  76  77  78  79  80  81  82  83  84  85  86  87  88  89  90\n##  [91]  91  92  93  94  95  96  97  98  99 100\nkaraktervektor <- c(\"a\", \"b\", \"xyz\")\nkaraktervektor## [1] \"a\"   \"b\"   \"xyz\"\nc(1, \"a\")## [1] \"1\" \"a\"\nc(2, TRUE)## [1] 2 1\nszamvektor <- c(elso = 4, masodik = 1, harmadik = 7)\nszamvektor##     elso  masodik harmadik \n##        4        1        7\nnames(szamvektor)## [1] \"elso\"     \"masodik\"  \"harmadik\"\nnames(szamvektor) <- c(\"egy\", \"ketto\", \"harom\")\nszamvektor##   egy ketto harom \n##     4     1     7\nszamvektor[3]## harom \n##     7\nszamvektor[c(1, 3)]##   egy harom \n##     4     7\nszamvektor[c(2, 2, 1, 3, 2, 3, 1, 1)]## ketto ketto   egy harom ketto harom   egy   egy \n##     1     1     4     7     1     7     4     4\nszamvektor[10]## <NA> \n##   NA\nszamvektor[c(TRUE, FALSE, TRUE, TRUE, FALSE, TRUE)]##   egy harom  <NA>  <NA> \n##     4     7    NA    NA\nszamvektor[c(TRUE, TRUE, FALSE)]##   egy ketto \n##     4     1\nszamvektor[-3]##   egy ketto \n##     4     1\nszamvektor[-c(1, 3)]## ketto \n##     1\nszamvektor[\"masodik\"]## <NA> \n##   NA\nszamvektor[c(\"masodik\", \"utolso\")]## <NA> <NA> \n##   NA   NA\nszamvektor[ 3 ] <- 99\nszamvektor##   egy ketto harom \n##     4     1    99\nszamvektor[ 10 ]## <NA> \n##   NA\nszamvektor[ 10 ] <- 999\nszamvektor##   egy ketto harom                                           \n##     4     1    99    NA    NA    NA    NA    NA    NA   999"},{"path":"adattípusok-adatszerkezetek.html","id":"mátrix","chapter":"3 . fejezet Adattípusok, adatszerkezetek","heading":"3.3.2 Mátrix","text":"mátrix homogén, kétdimenziós adatszerkezet.Legegyszerűbben úgy tölthető fel, ha egy vektort áttördelünk, matrix függvény használatával (az nc argumentummal az oszlopok, az nr argumentummal sorok számát állíthatjuk , értelemszerűen elég kettőből egyet megadni):Alapból oszlopok szerint tördel, de byrow argumentummal ezt átállíthatjuk:dimenzió, illetve külön sorok és oszlopok száma könnyen lekérhető:mátrix oszlopai és sorai elnevezhetőek, emiatt itt nem egy names van, hanem egy row.names és egy names, ez utóbbi az oszlopnév, de egyebekben teljesen hasonlóan viselkednek.Indexelés ugyanúgy végezhető, csak épp mindkét dimenzióra mondanunk kell valamit; kettő vesszővel választandó el:Mindkét dimenzió tetszőleges korábban látott módon indexelhető, tehát különböző módok keverhetőek :Ha egy dimenziót nem indexelünk, akkor az R úgy érti, hogy onnan minden elem (de vessző ekkor sem hagyható el!):","code":"\nszammatrix <- matrix( 1:6, nc = 2 )\nszammatrix##      [,1] [,2]\n## [1,]    1    4\n## [2,]    2    5\n## [3,]    3    6\nmatrix( 1:6, nc = 2, byrow = TRUE )##      [,1] [,2]\n## [1,]    1    2\n## [2,]    3    4\n## [3,]    5    6\ndim( szammatrix )## [1] 3 2\nnrow( szammatrix )## [1] 3\nncol( szammatrix )## [1] 2\nszammatrix[ c( 2, 3 ), 2 ]## [1] 5 6\nszammatrix[ c( 1, 2 ), c( T, F ) ]## [1] 1 2\nszammatrix[ 2, ]## [1] 2 5"},{"path":"adattípusok-adatszerkezetek.html","id":"tömb-array","chapter":"3 . fejezet Adattípusok, adatszerkezetek","heading":"3.3.3 Tömb (array)","text":"tömb (array) homogén, \\(n\\)-dimenziós adatszerkezet (nem foglalkozunk vele részletesebben, ritkán használatos).","code":""},{"path":"adattípusok-adatszerkezetek.html","id":"data-frame","chapter":"3 . fejezet Adattípusok, adatszerkezetek","heading":"3.3.4 Data frame","text":"data frame (adatkeret) heterogén, kétdimenziós, rektanguláris adatszerkezet. Pontosabban szólva félig heterogén: az oszlopok homogének, de különböző oszlopok típusai eltérhetnek egymástól. Lényegében tehát - nem feltétlenül ugyanolyan típusú - vektorok összefogva; rektanguláris azt jelenti, hogy minden vektor ugyanolyan hosszú kell legyen.Ez legtipikusabb adatszerkezet orvosi adatok tárolására: sorokban megfigyelési egységek, oszlopokban változók.data paranccsal egy kiegészítő csomagban található kész adat tölthető :Csak felső néhány sor head paranccsal kérhető le (az alsó néhány sor pedig tail-lel):Az oszlopok és sorok elnevezhetőek:Az adatkeret mátrixhoz hasonlóan indexelhető:Sőt, ha vannak elnevezéseink, az használható. következő 4 mind egyenértékű:nem dupla szögletes zárójellel történő indexelés eltérése, hogy nem kiválasztott vektort, hanem egy csak kiválasztott vektorból álló data frame-et ad vissza:Használhatunk különféle módszereket (az alábbiak közül második logikai indexelés miatt fog működni):Az adatkeret heterogén:","code":"\ndata( birthwt, package = \"MASS\" )\nbirthwt##     low age lwt race smoke ptl ht ui ftv  bwt\n## 85    0  19 182    2     0   0  0  1   0 2523\n## 86    0  33 155    3     0   0  0  0   3 2551\n## 87    0  20 105    1     1   0  0  0   1 2557\n## 88    0  21 108    1     1   0  0  1   2 2594\n## 89    0  18 107    1     1   0  0  1   0 2600\n## 91    0  21 124    3     0   0  0  0   0 2622\n## 92    0  22 118    1     0   0  0  0   1 2637\n## 93    0  17 103    3     0   0  0  0   1 2637\n## 94    0  29 123    1     1   0  0  0   1 2663\n## 95    0  26 113    1     1   0  0  0   0 2665\n## 96    0  19  95    3     0   0  0  0   0 2722\n## 97    0  19 150    3     0   0  0  0   1 2733\n## 98    0  22  95    3     0   0  1  0   0 2751\n## 99    0  30 107    3     0   1  0  1   2 2750\n## 100   0  18 100    1     1   0  0  0   0 2769\n## 101   0  18 100    1     1   0  0  0   0 2769\n## 102   0  15  98    2     0   0  0  0   0 2778\n## 103   0  25 118    1     1   0  0  0   3 2782\n## 104   0  20 120    3     0   0  0  1   0 2807\n## 105   0  28 120    1     1   0  0  0   1 2821\n## 106   0  32 121    3     0   0  0  0   2 2835\n## 107   0  31 100    1     0   0  0  1   3 2835\n## 108   0  36 202    1     0   0  0  0   1 2836\n## 109   0  28 120    3     0   0  0  0   0 2863\n## 111   0  25 120    3     0   0  0  1   2 2877\n## 112   0  28 167    1     0   0  0  0   0 2877\n## 113   0  17 122    1     1   0  0  0   0 2906\n## 114   0  29 150    1     0   0  0  0   2 2920\n## 115   0  26 168    2     1   0  0  0   0 2920\n## 116   0  17 113    2     0   0  0  0   1 2920\n## 117   0  17 113    2     0   0  0  0   1 2920\n## 118   0  24  90    1     1   1  0  0   1 2948\n## 119   0  35 121    2     1   1  0  0   1 2948\n## 120   0  25 155    1     0   0  0  0   1 2977\n## 121   0  25 125    2     0   0  0  0   0 2977\n## 123   0  29 140    1     1   0  0  0   2 2977\n## 124   0  19 138    1     1   0  0  0   2 2977\n## 125   0  27 124    1     1   0  0  0   0 2922\n## 126   0  31 215    1     1   0  0  0   2 3005\n## 127   0  33 109    1     1   0  0  0   1 3033\n## 128   0  21 185    2     1   0  0  0   2 3042\n## 129   0  19 189    1     0   0  0  0   2 3062\n## 130   0  23 130    2     0   0  0  0   1 3062\n## 131   0  21 160    1     0   0  0  0   0 3062\n## 132   0  18  90    1     1   0  0  1   0 3062\n## 133   0  18  90    1     1   0  0  1   0 3062\n## 134   0  32 132    1     0   0  0  0   4 3080\n## 135   0  19 132    3     0   0  0  0   0 3090\n## 136   0  24 115    1     0   0  0  0   2 3090\n## 137   0  22  85    3     1   0  0  0   0 3090\n## 138   0  22 120    1     0   0  1  0   1 3100\n## 139   0  23 128    3     0   0  0  0   0 3104\n## 140   0  22 130    1     1   0  0  0   0 3132\n## 141   0  30  95    1     1   0  0  0   2 3147\n## 142   0  19 115    3     0   0  0  0   0 3175\n## 143   0  16 110    3     0   0  0  0   0 3175\n## 144   0  21 110    3     1   0  0  1   0 3203\n## 145   0  30 153    3     0   0  0  0   0 3203\n## 146   0  20 103    3     0   0  0  0   0 3203\n## 147   0  17 119    3     0   0  0  0   0 3225\n## 148   0  17 119    3     0   0  0  0   0 3225\n## 149   0  23 119    3     0   0  0  0   2 3232\n## 150   0  24 110    3     0   0  0  0   0 3232\n## 151   0  28 140    1     0   0  0  0   0 3234\n## 154   0  26 133    3     1   2  0  0   0 3260\n## 155   0  20 169    3     0   1  0  1   1 3274\n## 156   0  24 115    3     0   0  0  0   2 3274\n## 159   0  28 250    3     1   0  0  0   6 3303\n## 160   0  20 141    1     0   2  0  1   1 3317\n## 161   0  22 158    2     0   1  0  0   2 3317\n## 162   0  22 112    1     1   2  0  0   0 3317\n## 163   0  31 150    3     1   0  0  0   2 3321\n## 164   0  23 115    3     1   0  0  0   1 3331\n## 166   0  16 112    2     0   0  0  0   0 3374\n## 167   0  16 135    1     1   0  0  0   0 3374\n## 168   0  18 229    2     0   0  0  0   0 3402\n## 169   0  25 140    1     0   0  0  0   1 3416\n## 170   0  32 134    1     1   1  0  0   4 3430\n## 172   0  20 121    2     1   0  0  0   0 3444\n## 173   0  23 190    1     0   0  0  0   0 3459\n## 174   0  22 131    1     0   0  0  0   1 3460\n## 175   0  32 170    1     0   0  0  0   0 3473\n## 176   0  30 110    3     0   0  0  0   0 3544\n## 177   0  20 127    3     0   0  0  0   0 3487\n## 179   0  23 123    3     0   0  0  0   0 3544\n## 180   0  17 120    3     1   0  0  0   0 3572\n## 181   0  19 105    3     0   0  0  0   0 3572\n## 182   0  23 130    1     0   0  0  0   0 3586\n## 183   0  36 175    1     0   0  0  0   0 3600\n## 184   0  22 125    1     0   0  0  0   1 3614\n## 185   0  24 133    1     0   0  0  0   0 3614\n## 186   0  21 134    3     0   0  0  0   2 3629\n## 187   0  19 235    1     1   0  1  0   0 3629\n## 188   0  25  95    1     1   3  0  1   0 3637\n## 189   0  16 135    1     1   0  0  0   0 3643\n## 190   0  29 135    1     0   0  0  0   1 3651\n## 191   0  29 154    1     0   0  0  0   1 3651\n## 192   0  19 147    1     1   0  0  0   0 3651\n## 193   0  19 147    1     1   0  0  0   0 3651\n## 195   0  30 137    1     0   0  0  0   1 3699\n## 196   0  24 110    1     0   0  0  0   1 3728\n## 197   0  19 184    1     1   0  1  0   0 3756\n## 199   0  24 110    3     0   1  0  0   0 3770\n## 200   0  23 110    1     0   0  0  0   1 3770\n## 201   0  20 120    3     0   0  0  0   0 3770\n## 202   0  25 241    2     0   0  1  0   0 3790\n## 203   0  30 112    1     0   0  0  0   1 3799\n## 204   0  22 169    1     0   0  0  0   0 3827\n## 205   0  18 120    1     1   0  0  0   2 3856\n## 206   0  16 170    2     0   0  0  0   4 3860\n## 207   0  32 186    1     0   0  0  0   2 3860\n## 208   0  18 120    3     0   0  0  0   1 3884\n## 209   0  29 130    1     1   0  0  0   2 3884\n## 210   0  33 117    1     0   0  0  1   1 3912\n## 211   0  20 170    1     1   0  0  0   0 3940\n## 212   0  28 134    3     0   0  0  0   1 3941\n## 213   0  14 135    1     0   0  0  0   0 3941\n## 214   0  28 130    3     0   0  0  0   0 3969\n## 215   0  25 120    1     0   0  0  0   2 3983\n## 216   0  16  95    3     0   0  0  0   1 3997\n## 217   0  20 158    1     0   0  0  0   1 3997\n## 218   0  26 160    3     0   0  0  0   0 4054\n## 219   0  21 115    1     0   0  0  0   1 4054\n## 220   0  22 129    1     0   0  0  0   0 4111\n## 221   0  25 130    1     0   0  0  0   2 4153\n## 222   0  31 120    1     0   0  0  0   2 4167\n## 223   0  35 170    1     0   1  0  0   1 4174\n## 224   0  19 120    1     1   0  0  0   0 4238\n## 225   0  24 116    1     0   0  0  0   1 4593\n## 226   0  45 123    1     0   0  0  0   1 4990\n## 4     1  28 120    3     1   1  0  1   0  709\n## 10    1  29 130    1     0   0  0  1   2 1021\n## 11    1  34 187    2     1   0  1  0   0 1135\n## 13    1  25 105    3     0   1  1  0   0 1330\n## 15    1  25  85    3     0   0  0  1   0 1474\n## 16    1  27 150    3     0   0  0  0   0 1588\n## 17    1  23  97    3     0   0  0  1   1 1588\n## 18    1  24 128    2     0   1  0  0   1 1701\n## 19    1  24 132    3     0   0  1  0   0 1729\n## 20    1  21 165    1     1   0  1  0   1 1790\n## 22    1  32 105    1     1   0  0  0   0 1818\n## 23    1  19  91    1     1   2  0  1   0 1885\n## 24    1  25 115    3     0   0  0  0   0 1893\n## 25    1  16 130    3     0   0  0  0   1 1899\n## 26    1  25  92    1     1   0  0  0   0 1928\n## 27    1  20 150    1     1   0  0  0   2 1928\n## 28    1  21 200    2     0   0  0  1   2 1928\n## 29    1  24 155    1     1   1  0  0   0 1936\n## 30    1  21 103    3     0   0  0  0   0 1970\n## 31    1  20 125    3     0   0  0  1   0 2055\n## 32    1  25  89    3     0   2  0  0   1 2055\n## 33    1  19 102    1     0   0  0  0   2 2082\n## 34    1  19 112    1     1   0  0  1   0 2084\n## 35    1  26 117    1     1   1  0  0   0 2084\n## 36    1  24 138    1     0   0  0  0   0 2100\n## 37    1  17 130    3     1   1  0  1   0 2125\n## 40    1  20 120    2     1   0  0  0   3 2126\n## 42    1  22 130    1     1   1  0  1   1 2187\n## 43    1  27 130    2     0   0  0  1   0 2187\n## 44    1  20  80    3     1   0  0  1   0 2211\n## 45    1  17 110    1     1   0  0  0   0 2225\n## 46    1  25 105    3     0   1  0  0   1 2240\n## 47    1  20 109    3     0   0  0  0   0 2240\n## 49    1  18 148    3     0   0  0  0   0 2282\n## 50    1  18 110    2     1   1  0  0   0 2296\n## 51    1  20 121    1     1   1  0  1   0 2296\n## 52    1  21 100    3     0   1  0  0   4 2301\n## 54    1  26  96    3     0   0  0  0   0 2325\n## 56    1  31 102    1     1   1  0  0   1 2353\n## 57    1  15 110    1     0   0  0  0   0 2353\n## 59    1  23 187    2     1   0  0  0   1 2367\n## 60    1  20 122    2     1   0  0  0   0 2381\n## 61    1  24 105    2     1   0  0  0   0 2381\n## 62    1  15 115    3     0   0  0  1   0 2381\n## 63    1  23 120    3     0   0  0  0   0 2410\n## 65    1  30 142    1     1   1  0  0   0 2410\n## 67    1  22 130    1     1   0  0  0   1 2410\n## 68    1  17 120    1     1   0  0  0   3 2414\n## 69    1  23 110    1     1   1  0  0   0 2424\n## 71    1  17 120    2     0   0  0  0   2 2438\n## 75    1  26 154    3     0   1  1  0   1 2442\n## 76    1  20 105    3     0   0  0  0   3 2450\n## 77    1  26 190    1     1   0  0  0   0 2466\n## 78    1  14 101    3     1   1  0  0   0 2466\n## 79    1  28  95    1     1   0  0  0   2 2466\n## 81    1  14 100    3     0   0  0  0   2 2495\n## 82    1  23  94    3     1   0  0  0   0 2495\n## 83    1  17 142    2     0   0  1  0   0 2495\n## 84    1  21 130    1     1   0  1  0   3 2495\nhead( birthwt )##    low age lwt race smoke ptl ht ui ftv  bwt\n## 85   0  19 182    2     0   0  0  1   0 2523\n## 86   0  33 155    3     0   0  0  0   3 2551\n## 87   0  20 105    1     1   0  0  0   1 2557\n## 88   0  21 108    1     1   0  0  1   2 2594\n## 89   0  18 107    1     1   0  0  1   0 2600\n## 91   0  21 124    3     0   0  0  0   0 2622\nstr( birthwt )## 'data.frame':    189 obs. of  10 variables:\n##  $ low  : int  0 0 0 0 0 0 0 0 0 0 ...\n##  $ age  : int  19 33 20 21 18 21 22 17 29 26 ...\n##  $ lwt  : int  182 155 105 108 107 124 118 103 123 113 ...\n##  $ race : int  2 3 1 1 1 3 1 3 1 1 ...\n##  $ smoke: int  0 0 1 1 1 0 0 0 1 1 ...\n##  $ ptl  : int  0 0 0 0 0 0 0 0 0 0 ...\n##  $ ht   : int  0 0 0 0 0 0 0 0 0 0 ...\n##  $ ui   : int  1 0 0 1 1 0 0 0 0 0 ...\n##  $ ftv  : int  0 3 1 2 0 0 1 1 1 0 ...\n##  $ bwt  : int  2523 2551 2557 2594 2600 2622 2637 2637 2663 2665 ...\nnames( birthwt )##  [1] \"low\"   \"age\"   \"lwt\"   \"race\"  \"smoke\" \"ptl\"   \"ht\"    \"ui\"    \"ftv\"  \n## [10] \"bwt\"\ncolnames( birthwt )##  [1] \"low\"   \"age\"   \"lwt\"   \"race\"  \"smoke\" \"ptl\"   \"ht\"    \"ui\"    \"ftv\"  \n## [10] \"bwt\"\nbirthwt[ 3, ]##    low age lwt race smoke ptl ht ui ftv  bwt\n## 87   0  20 105    1     1   0  0  0   1 2557\nbirthwt[ 3, 4 ]## [1] 1\nbirthwt[ 3, c( 5, 6 ) ]##    smoke ptl\n## 87     1   0\nbirthwt[ , 10  ]##   [1] 2523 2551 2557 2594 2600 2622 2637 2637 2663 2665 2722 2733 2751 2750 2769\n##  [16] 2769 2778 2782 2807 2821 2835 2835 2836 2863 2877 2877 2906 2920 2920 2920\n##  [31] 2920 2948 2948 2977 2977 2977 2977 2922 3005 3033 3042 3062 3062 3062 3062\n##  [46] 3062 3080 3090 3090 3090 3100 3104 3132 3147 3175 3175 3203 3203 3203 3225\n##  [61] 3225 3232 3232 3234 3260 3274 3274 3303 3317 3317 3317 3321 3331 3374 3374\n##  [76] 3402 3416 3430 3444 3459 3460 3473 3544 3487 3544 3572 3572 3586 3600 3614\n##  [91] 3614 3629 3629 3637 3643 3651 3651 3651 3651 3699 3728 3756 3770 3770 3770\n## [106] 3790 3799 3827 3856 3860 3860 3884 3884 3912 3940 3941 3941 3969 3983 3997\n## [121] 3997 4054 4054 4111 4153 4167 4174 4238 4593 4990  709 1021 1135 1330 1474\n## [136] 1588 1588 1701 1729 1790 1818 1885 1893 1899 1928 1928 1928 1936 1970 2055\n## [151] 2055 2082 2084 2084 2100 2125 2126 2187 2187 2211 2225 2240 2240 2282 2296\n## [166] 2296 2301 2325 2353 2353 2367 2381 2381 2381 2410 2410 2410 2414 2424 2438\n## [181] 2442 2450 2466 2466 2466 2495 2495 2495 2495\nbirthwt$bwt##   [1] 2523 2551 2557 2594 2600 2622 2637 2637 2663 2665 2722 2733 2751 2750 2769\n##  [16] 2769 2778 2782 2807 2821 2835 2835 2836 2863 2877 2877 2906 2920 2920 2920\n##  [31] 2920 2948 2948 2977 2977 2977 2977 2922 3005 3033 3042 3062 3062 3062 3062\n##  [46] 3062 3080 3090 3090 3090 3100 3104 3132 3147 3175 3175 3203 3203 3203 3225\n##  [61] 3225 3232 3232 3234 3260 3274 3274 3303 3317 3317 3317 3321 3331 3374 3374\n##  [76] 3402 3416 3430 3444 3459 3460 3473 3544 3487 3544 3572 3572 3586 3600 3614\n##  [91] 3614 3629 3629 3637 3643 3651 3651 3651 3651 3699 3728 3756 3770 3770 3770\n## [106] 3790 3799 3827 3856 3860 3860 3884 3884 3912 3940 3941 3941 3969 3983 3997\n## [121] 3997 4054 4054 4111 4153 4167 4174 4238 4593 4990  709 1021 1135 1330 1474\n## [136] 1588 1588 1701 1729 1790 1818 1885 1893 1899 1928 1928 1928 1936 1970 2055\n## [151] 2055 2082 2084 2084 2100 2125 2126 2187 2187 2211 2225 2240 2240 2282 2296\n## [166] 2296 2301 2325 2353 2353 2367 2381 2381 2381 2410 2410 2410 2414 2424 2438\n## [181] 2442 2450 2466 2466 2466 2495 2495 2495 2495\nbirthwt[ , \"bwt\" ]##   [1] 2523 2551 2557 2594 2600 2622 2637 2637 2663 2665 2722 2733 2751 2750 2769\n##  [16] 2769 2778 2782 2807 2821 2835 2835 2836 2863 2877 2877 2906 2920 2920 2920\n##  [31] 2920 2948 2948 2977 2977 2977 2977 2922 3005 3033 3042 3062 3062 3062 3062\n##  [46] 3062 3080 3090 3090 3090 3100 3104 3132 3147 3175 3175 3203 3203 3203 3225\n##  [61] 3225 3232 3232 3234 3260 3274 3274 3303 3317 3317 3317 3321 3331 3374 3374\n##  [76] 3402 3416 3430 3444 3459 3460 3473 3544 3487 3544 3572 3572 3586 3600 3614\n##  [91] 3614 3629 3629 3637 3643 3651 3651 3651 3651 3699 3728 3756 3770 3770 3770\n## [106] 3790 3799 3827 3856 3860 3860 3884 3884 3912 3940 3941 3941 3969 3983 3997\n## [121] 3997 4054 4054 4111 4153 4167 4174 4238 4593 4990  709 1021 1135 1330 1474\n## [136] 1588 1588 1701 1729 1790 1818 1885 1893 1899 1928 1928 1928 1936 1970 2055\n## [151] 2055 2082 2084 2084 2100 2125 2126 2187 2187 2211 2225 2240 2240 2282 2296\n## [166] 2296 2301 2325 2353 2353 2367 2381 2381 2381 2410 2410 2410 2414 2424 2438\n## [181] 2442 2450 2466 2466 2466 2495 2495 2495 2495\nbirthwt[[ \"bwt\" ]]##   [1] 2523 2551 2557 2594 2600 2622 2637 2637 2663 2665 2722 2733 2751 2750 2769\n##  [16] 2769 2778 2782 2807 2821 2835 2835 2836 2863 2877 2877 2906 2920 2920 2920\n##  [31] 2920 2948 2948 2977 2977 2977 2977 2922 3005 3033 3042 3062 3062 3062 3062\n##  [46] 3062 3080 3090 3090 3090 3100 3104 3132 3147 3175 3175 3203 3203 3203 3225\n##  [61] 3225 3232 3232 3234 3260 3274 3274 3303 3317 3317 3317 3321 3331 3374 3374\n##  [76] 3402 3416 3430 3444 3459 3460 3473 3544 3487 3544 3572 3572 3586 3600 3614\n##  [91] 3614 3629 3629 3637 3643 3651 3651 3651 3651 3699 3728 3756 3770 3770 3770\n## [106] 3790 3799 3827 3856 3860 3860 3884 3884 3912 3940 3941 3941 3969 3983 3997\n## [121] 3997 4054 4054 4111 4153 4167 4174 4238 4593 4990  709 1021 1135 1330 1474\n## [136] 1588 1588 1701 1729 1790 1818 1885 1893 1899 1928 1928 1928 1936 1970 2055\n## [151] 2055 2082 2084 2084 2100 2125 2126 2187 2187 2211 2225 2240 2240 2282 2296\n## [166] 2296 2301 2325 2353 2353 2367 2381 2381 2381 2410 2410 2410 2414 2424 2438\n## [181] 2442 2450 2466 2466 2466 2495 2495 2495 2495\nbirthwt[[ \"bwt\" ]]##   [1] 2523 2551 2557 2594 2600 2622 2637 2637 2663 2665 2722 2733 2751 2750 2769\n##  [16] 2769 2778 2782 2807 2821 2835 2835 2836 2863 2877 2877 2906 2920 2920 2920\n##  [31] 2920 2948 2948 2977 2977 2977 2977 2922 3005 3033 3042 3062 3062 3062 3062\n##  [46] 3062 3080 3090 3090 3090 3100 3104 3132 3147 3175 3175 3203 3203 3203 3225\n##  [61] 3225 3232 3232 3234 3260 3274 3274 3303 3317 3317 3317 3321 3331 3374 3374\n##  [76] 3402 3416 3430 3444 3459 3460 3473 3544 3487 3544 3572 3572 3586 3600 3614\n##  [91] 3614 3629 3629 3637 3643 3651 3651 3651 3651 3699 3728 3756 3770 3770 3770\n## [106] 3790 3799 3827 3856 3860 3860 3884 3884 3912 3940 3941 3941 3969 3983 3997\n## [121] 3997 4054 4054 4111 4153 4167 4174 4238 4593 4990  709 1021 1135 1330 1474\n## [136] 1588 1588 1701 1729 1790 1818 1885 1893 1899 1928 1928 1928 1936 1970 2055\n## [151] 2055 2082 2084 2084 2100 2125 2126 2187 2187 2211 2225 2240 2240 2282 2296\n## [166] 2296 2301 2325 2353 2353 2367 2381 2381 2381 2410 2410 2410 2414 2424 2438\n## [181] 2442 2450 2466 2466 2466 2495 2495 2495 2495\nstr( birthwt[[ \"bwt\" ]] )##  int [1:189] 2523 2551 2557 2594 2600 2622 2637 2637 2663 2665 ...\nhead( birthwt[ \"bwt\" ] )##     bwt\n## 85 2523\n## 86 2551\n## 87 2557\n## 88 2594\n## 89 2600\n## 91 2622\nstr( birthwt[ \"bwt\" ] )## 'data.frame':    189 obs. of  1 variable:\n##  $ bwt: int  2523 2551 2557 2594 2600 2622 2637 2637 2663 2665 ...\nhead( birthwt[ , c( \"lwt\", \"smoke\" ) ] )##    lwt smoke\n## 85 182     0\n## 86 155     0\n## 87 105     1\n## 88 108     1\n## 89 107     1\n## 91 124     0\nhead( birthwt[ birthwt$smoke==1, ] )##     low age lwt race smoke ptl ht ui ftv  bwt\n## 87    0  20 105    1     1   0  0  0   1 2557\n## 88    0  21 108    1     1   0  0  1   2 2594\n## 89    0  18 107    1     1   0  0  1   0 2600\n## 94    0  29 123    1     1   0  0  0   1 2663\n## 95    0  26 113    1     1   0  0  0   0 2665\n## 100   0  18 100    1     1   0  0  0   0 2769\nhead( birthwt[ birthwt$smoke==1&birthwt$race==1, ] )##     low age lwt race smoke ptl ht ui ftv  bwt\n## 87    0  20 105    1     1   0  0  0   1 2557\n## 88    0  21 108    1     1   0  0  1   2 2594\n## 89    0  18 107    1     1   0  0  1   0 2600\n## 94    0  29 123    1     1   0  0  0   1 2663\n## 95    0  26 113    1     1   0  0  0   0 2665\n## 100   0  18 100    1     1   0  0  0   0 2769\nbirthwt$nev <- \"a\"\nhead( birthwt )##    low age lwt race smoke ptl ht ui ftv  bwt nev\n## 85   0  19 182    2     0   0  0  1   0 2523   a\n## 86   0  33 155    3     0   0  0  0   3 2551   a\n## 87   0  20 105    1     1   0  0  0   1 2557   a\n## 88   0  21 108    1     1   0  0  1   2 2594   a\n## 89   0  18 107    1     1   0  0  1   0 2600   a\n## 91   0  21 124    3     0   0  0  0   0 2622   a\nstr( birthwt )## 'data.frame':    189 obs. of  11 variables:\n##  $ low  : int  0 0 0 0 0 0 0 0 0 0 ...\n##  $ age  : int  19 33 20 21 18 21 22 17 29 26 ...\n##  $ lwt  : int  182 155 105 108 107 124 118 103 123 113 ...\n##  $ race : int  2 3 1 1 1 3 1 3 1 1 ...\n##  $ smoke: int  0 0 1 1 1 0 0 0 1 1 ...\n##  $ ptl  : int  0 0 0 0 0 0 0 0 0 0 ...\n##  $ ht   : int  0 0 0 0 0 0 0 0 0 0 ...\n##  $ ui   : int  1 0 0 1 1 0 0 0 0 0 ...\n##  $ ftv  : int  0 3 1 2 0 0 1 1 1 0 ...\n##  $ bwt  : int  2523 2551 2557 2594 2600 2622 2637 2637 2663 2665 ...\n##  $ nev  : chr  \"a\" \"a\" \"a\" \"a\" ..."},{"path":"adattípusok-adatszerkezetek.html","id":"lista","chapter":"3 . fejezet Adattípusok, adatszerkezetek","heading":"3.3.5 Lista","text":"lista heterogén, egydimenziós adatszerkezet.Legegyszerűbben elemei felsorolásával hozható létre, list függvényt használva:Számmal és – ha van neki – névvel indexelhető:Az egy zárójellel történő indexelés látszólag ugyanaz, de csak látszólag:Tartomány indexelhető:Az előbbi dolgok természetesen kombinálhatóak :Az adatkeret igazából egy, az oszlopokból - mint vektorokból - összerakott lista (tehát két szűkítés van: az elemek csak vektorok lehetnek és ugyanolyan hosszúaknak kell lenniük).","code":"\nlista <- list( sz = szamvektor, k = karaktervektor, m = szammatrix, df = birthwt[ 1:5, ] )\nlista## $sz\n##   egy ketto harom                                           \n##     4     1    99    NA    NA    NA    NA    NA    NA   999 \n## \n## $k\n## [1] \"a\"   \"b\"   \"xyz\"\n## \n## $m\n##      [,1] [,2]\n## [1,]    1    4\n## [2,]    2    5\n## [3,]    3    6\n## \n## $df\n##    low age lwt race smoke ptl ht ui ftv  bwt nev\n## 85   0  19 182    2     0   0  0  1   0 2523   a\n## 86   0  33 155    3     0   0  0  0   3 2551   a\n## 87   0  20 105    1     1   0  0  0   1 2557   a\n## 88   0  21 108    1     1   0  0  1   2 2594   a\n## 89   0  18 107    1     1   0  0  1   0 2600   a\nstr( lista )## List of 4\n##  $ sz: Named num [1:10] 4 1 99 NA NA NA NA NA NA 999\n##   ..- attr(*, \"names\")= chr [1:10] \"egy\" \"ketto\" \"harom\" \"\" ...\n##  $ k : chr [1:3] \"a\" \"b\" \"xyz\"\n##  $ m : int [1:3, 1:2] 1 2 3 4 5 6\n##  $ df:'data.frame':  5 obs. of  11 variables:\n##   ..$ low  : int [1:5] 0 0 0 0 0\n##   ..$ age  : int [1:5] 19 33 20 21 18\n##   ..$ lwt  : int [1:5] 182 155 105 108 107\n##   ..$ race : int [1:5] 2 3 1 1 1\n##   ..$ smoke: int [1:5] 0 0 1 1 1\n##   ..$ ptl  : int [1:5] 0 0 0 0 0\n##   ..$ ht   : int [1:5] 0 0 0 0 0\n##   ..$ ui   : int [1:5] 1 0 0 1 1\n##   ..$ ftv  : int [1:5] 0 3 1 2 0\n##   ..$ bwt  : int [1:5] 2523 2551 2557 2594 2600\n##   ..$ nev  : chr [1:5] \"a\" \"a\" \"a\" \"a\" ...\nlista[[ 1 ]]##   egy ketto harom                                           \n##     4     1    99    NA    NA    NA    NA    NA    NA   999\nlista$sz##   egy ketto harom                                           \n##     4     1    99    NA    NA    NA    NA    NA    NA   999\nlista[[ \"sz\" ]]##   egy ketto harom                                           \n##     4     1    99    NA    NA    NA    NA    NA    NA   999\nlista[ 1 ]## $sz\n##   egy ketto harom                                           \n##     4     1    99    NA    NA    NA    NA    NA    NA   999\ntypeof( lista[[ 1 ]] )## [1] \"double\"\ntypeof( lista[ 1 ] )## [1] \"list\"\nlista[ 1:2 ]## $sz\n##   egy ketto harom                                           \n##     4     1    99    NA    NA    NA    NA    NA    NA   999 \n## \n## $k\n## [1] \"a\"   \"b\"   \"xyz\"\nlista[[ 1:2 ]]## [1] 1\nidx <- \"sz\"\nlista[[ idx ]]##   egy ketto harom                                           \n##     4     1    99    NA    NA    NA    NA    NA    NA   999"},{"path":"függvények.html","id":"függvények","chapter":"4 . fejezet Függvények","heading":"4 . fejezet Függvények","text":"függvényekről","code":""},{"path":"függvények.html","id":"függvényhívások","chapter":"4 . fejezet Függvények","heading":"4.1 Függvényhívások","text":"Függvény úgy hívható, hogy megadjuk nevét, majd utána zárójelben az argumentumát, vagy argumentumait (lehet, hogy egy sincs, de zárójelet ekkor ki kell írni):Függvényről súgó kérdőjellel kapható (két kérdőjel az összes ismert függvényt végigkeresi, akár névtöredékre ): ?quantile.Aminél egyenlőségjellel adva van érték specifikációban, ott az default-ként viselkedik, nem kötelező megadni, viszont default-tal nem rendelkezőket muszáj:Ha több argumentumot adunk meg, akkor azok felsorolás sorrendjében osztódnak ki:Argumentumra hivatkozhatunk névvel , ez esetben nem kell felsorolás sorrendjével törődnünk:Az általános gyakorlat az, hogy az első két-három argumentumot adhatjuk meg név nélkül (ezeknél elvárható, hogy fejből tudja az ember, hogy mit jelent), de többinél elegánsabb, ha mindenképp adunk nevet (tehát akkor , ha sorrendben írjuk).Egy függvény hívásánál az argumentumai elkülöníthetőek egy listába, majd ugyanaz hatása .call használatával elérhető (első argumentum függvény, második az átadandó argumentumok listája):Ez akkor jön jól, ha nem tudjuk előre, hogy mik az argumentumok (akár azt sem, hogy hány darab van belőlük!), pl. mert egy lapply-jal gyártottuk le, lásd később:","code":"\nquantile( birthwt$bwt )##   0%  25%  50%  75% 100% \n##  709 2414 2977 3487 4990\nquantile()## Error in quantile.default(): argument \"x\" is missing, with no default\nquantile( birthwt$bwt, 0.23 )##     23% \n## 2387.96\nquantile( birthwt$bwt, c( 0.23, 0.5, 0.6 ) )##     23%     50%     60% \n## 2387.96 2977.00 3169.40\nquantile( birthwt$bwt, c( 0.23, 0.5, 0.6 ), type = 6 )##  23%  50%  60% \n## 2381 2977 3175\nquantile( probs = c( 0.23, 0.5, 0.6 ), type = 6, x = birthwt$bwt )##  23%  50%  60% \n## 2381 2977 3175\nquantile( probs = c( 0.23, 0.5, 0.6 ), type = 6, x = birthwt$bwt )##  23%  50%  60% \n## 2381 2977 3175\ndo.call( quantile, list( probs = c( 0.23, 0.5, 0.6 ), type = 6, x = birthwt$bwt ) )##  23%  50%  60% \n## 2381 2977 3175\nrbind( c( 1, 2 ), c( 3, 4 ), c( 5, 6 ) )##      [,1] [,2]\n## [1,]    1    2\n## [2,]    3    4\n## [3,]    5    6\ndo.call( rbind, lapply( birthwt, function( x ) c( mean( x ), median( x ) ) ) )## Warning in mean.default(x): az argumentum nem numerikus vagy logikai: NA-t\n## eredményez##       [,1]                 [,2]  \n## low   \"0.312169312169312\"  \"0\"   \n## age   \"23.2380952380952\"   \"23\"  \n## lwt   \"129.814814814815\"   \"121\" \n## race  \"1.84656084656085\"   \"1\"   \n## smoke \"0.391534391534392\"  \"0\"   \n## ptl   \"0.195767195767196\"  \"0\"   \n## ht    \"0.0634920634920635\" \"0\"   \n## ui    \"0.148148148148148\"  \"0\"   \n## ftv   \"0.793650793650794\"  \"0\"   \n## bwt   \"2944.5873015873\"    \"2977\"\n## nev   NA                   \"a\""},{"path":"függvények.html","id":"saját-függény-definiálása","chapter":"4 . fejezet Függvények","heading":"4.2 Saját függény definiálása","text":"Ilyet lehet.","code":""},{"path":"az-r-programozása.html","id":"az-r-programozása","chapter":"5 . fejezet Az R programozása","heading":"5 . fejezet Az R programozása","text":"Programozás.","code":""},{"path":"az-r-programozása.html","id":"funkcionális-programozás","chapter":"5 . fejezet Az R programozása","heading":"5.1 Funkcionális programozás","text":"Az R, bár többféle paradigmában tud dolgozni, érezhető funkcionális nyelv. Ezt elegáns , célszerű kihasználni!Egy példa:lapply az első argumentumban megadott lista minden elemére ráereszti második argumentumban megadott függvényt, és az eredményt összefűzi egy listává (sapply csak annyiban tér el, hogy lista helyett vektort ad vissza, ha lehetséges listát vektorrá konvertálni):harmadik sor példát mutat arra, hogy anonim függvény használható, az utolsó előtti pedig arra, hogy data.frame igazából lista, aminek az elemei az oszlopai.Az apply az első argumentumban megadott mátrix vagy adatkeret minden sorára vagy oszlopára (ezt második argumentum dönti el) ráereszti harmadik argumentumban megadott függvényt:tapply az első argumentumban megadott változó második argumentum szerint képezett csoportjaira ráereszti harmadik argumentumban megadott függvényt:","code":"\nmean( birthwt$bwt[ 1:100 ] )## [1] 3130.16\nelsoszazatlag <- function( data ) {\n  result <- mean( data[ 1:100 ] )\n  return( result )\n}\n\nelsoszazatlag <- function( data ) {\n  result <- mean( data[ 1:100 ] )\n  result\n}\nelsoszazatlag <- function( data ) {\n  mean( data[ 1:100 ] )\n}\n\nelsoszazatlag( birthwt$bwt )## [1] 3130.16\nsd( birthwt$bwt[ 1:100 ] )## [1] 323.7243\nelsoszazf <- function( data, f = mean ) {\n  f( data[ 1:100 ] )\n}\nelsoszazf( birthwt$bwt )## [1] 3130.16\nelsoszazf( birthwt$bwt, f = sd )## [1] 323.7243\nlapply( c( \"age\", \"lwt\", \"bwt\" ), nchar )## [[1]]\n## [1] 3\n## \n## [[2]]\n## [1] 3\n## \n## [[3]]\n## [1] 3\nsapply( c( \"age\", \"lwt\", \"bwt\" ), nchar )## age lwt bwt \n##   3   3   3\nlapply( c( \"age\", \"lwt\", \"bwt\" ), function( x ) nchar( x ) )## [[1]]\n## [1] 3\n## \n## [[2]]\n## [1] 3\n## \n## [[3]]\n## [1] 3\nlapply( c( \"age\", \"lwt\", \"bwt\" ), function( x ) mean( birthwt[[ x ]] ) )## [[1]]\n## [1] 23.2381\n## \n## [[2]]\n## [1] 129.8148\n## \n## [[3]]\n## [1] 2944.587\nsapply( c( \"age\", \"lwt\", \"bwt\" ), function( x ) mean( birthwt[[ x ]] ) )##       age       lwt       bwt \n##   23.2381  129.8148 2944.5873\nsapply( birthwt, mean )## Warning in mean.default(X[[i]], ...): az argumentum nem numerikus vagy logikai:\n## NA-t eredményez##          low          age          lwt         race        smoke          ptl \n## 3.121693e-01 2.323810e+01 1.298148e+02 1.846561e+00 3.915344e-01 1.957672e-01 \n##           ht           ui          ftv          bwt          nev \n## 6.349206e-02 1.481481e-01 7.936508e-01 2.944587e+03           NA\nlapply( birthwt, function( x ) c( mean( x ), median( x ) ) )## Warning in mean.default(x): az argumentum nem numerikus vagy logikai: NA-t\n## eredményez## $low\n## [1] 0.3121693 0.0000000\n## \n## $age\n## [1] 23.2381 23.0000\n## \n## $lwt\n## [1] 129.8148 121.0000\n## \n## $race\n## [1] 1.846561 1.000000\n## \n## $smoke\n## [1] 0.3915344 0.0000000\n## \n## $ptl\n## [1] 0.1957672 0.0000000\n## \n## $ht\n## [1] 0.06349206 0.00000000\n## \n## $ui\n## [1] 0.1481481 0.0000000\n## \n## $ftv\n## [1] 0.7936508 0.0000000\n## \n## $bwt\n## [1] 2944.587 2977.000\n## \n## $nev\n## [1] NA  \"a\"\napply( birthwt, 2, mean )## Warning in mean.default(newX[, i], ...): az argumentum nem numerikus vagy\n## logikai: NA-t eredményez\n## Warning in mean.default(newX[, i], ...): az argumentum nem numerikus vagy\n## logikai: NA-t eredményez\n## Warning in mean.default(newX[, i], ...): az argumentum nem numerikus vagy\n## logikai: NA-t eredményez\n## Warning in mean.default(newX[, i], ...): az argumentum nem numerikus vagy\n## logikai: NA-t eredményez\n## Warning in mean.default(newX[, i], ...): az argumentum nem numerikus vagy\n## logikai: NA-t eredményez\n## Warning in mean.default(newX[, i], ...): az argumentum nem numerikus vagy\n## logikai: NA-t eredményez\n## Warning in mean.default(newX[, i], ...): az argumentum nem numerikus vagy\n## logikai: NA-t eredményez\n## Warning in mean.default(newX[, i], ...): az argumentum nem numerikus vagy\n## logikai: NA-t eredményez\n## Warning in mean.default(newX[, i], ...): az argumentum nem numerikus vagy\n## logikai: NA-t eredményez\n## Warning in mean.default(newX[, i], ...): az argumentum nem numerikus vagy\n## logikai: NA-t eredményez\n## Warning in mean.default(newX[, i], ...): az argumentum nem numerikus vagy\n## logikai: NA-t eredményez##   low   age   lwt  race smoke   ptl    ht    ui   ftv   bwt   nev \n##    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA\napply( birthwt, 1, function( x ) x[ 1 ] )##  85  86  87  88  89  91  92  93  94  95  96  97  98  99 100 101 102 103 104 105 \n## \"0\" \"0\" \"0\" \"0\" \"0\" \"0\" \"0\" \"0\" \"0\" \"0\" \"0\" \"0\" \"0\" \"0\" \"0\" \"0\" \"0\" \"0\" \"0\" \"0\" \n## 106 107 108 109 111 112 113 114 115 116 117 118 119 120 121 123 124 125 126 127 \n## \"0\" \"0\" \"0\" \"0\" \"0\" \"0\" \"0\" \"0\" \"0\" \"0\" \"0\" \"0\" \"0\" \"0\" \"0\" \"0\" \"0\" \"0\" \"0\" \"0\" \n## 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 \n## \"0\" \"0\" \"0\" \"0\" \"0\" \"0\" \"0\" \"0\" \"0\" \"0\" \"0\" \"0\" \"0\" \"0\" \"0\" \"0\" \"0\" \"0\" \"0\" \"0\" \n## 148 149 150 151 154 155 156 159 160 161 162 163 164 166 167 168 169 170 172 173 \n## \"0\" \"0\" \"0\" \"0\" \"0\" \"0\" \"0\" \"0\" \"0\" \"0\" \"0\" \"0\" \"0\" \"0\" \"0\" \"0\" \"0\" \"0\" \"0\" \"0\" \n## 174 175 176 177 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 195 \n## \"0\" \"0\" \"0\" \"0\" \"0\" \"0\" \"0\" \"0\" \"0\" \"0\" \"0\" \"0\" \"0\" \"0\" \"0\" \"0\" \"0\" \"0\" \"0\" \"0\" \n## 196 197 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 \n## \"0\" \"0\" \"0\" \"0\" \"0\" \"0\" \"0\" \"0\" \"0\" \"0\" \"0\" \"0\" \"0\" \"0\" \"0\" \"0\" \"0\" \"0\" \"0\" \"0\" \n## 217 218 219 220 221 222 223 224 225 226   4  10  11  13  15  16  17  18  19  20 \n## \"0\" \"0\" \"0\" \"0\" \"0\" \"0\" \"0\" \"0\" \"0\" \"0\" \"1\" \"1\" \"1\" \"1\" \"1\" \"1\" \"1\" \"1\" \"1\" \"1\" \n##  22  23  24  25  26  27  28  29  30  31  32  33  34  35  36  37  40  42  43  44 \n## \"1\" \"1\" \"1\" \"1\" \"1\" \"1\" \"1\" \"1\" \"1\" \"1\" \"1\" \"1\" \"1\" \"1\" \"1\" \"1\" \"1\" \"1\" \"1\" \"1\" \n##  45  46  47  49  50  51  52  54  56  57  59  60  61  62  63  65  67  68  69  71 \n## \"1\" \"1\" \"1\" \"1\" \"1\" \"1\" \"1\" \"1\" \"1\" \"1\" \"1\" \"1\" \"1\" \"1\" \"1\" \"1\" \"1\" \"1\" \"1\" \"1\" \n##  75  76  77  78  79  81  82  83  84 \n## \"1\" \"1\" \"1\" \"1\" \"1\" \"1\" \"1\" \"1\" \"1\"\nmean( birthwt$bwt[ birthwt$race==1 ] )## [1] 3102.719\ntapply( birthwt$bwt, birthwt$race, mean )##        1        2        3 \n## 3102.719 2719.692 2805.284"},{"path":"data-table-egy-továbbfejlesztett-adatkeret.html","id":"data-table-egy-továbbfejlesztett-adatkeret","chapter":"6 . fejezet Data table: egy továbbfejlesztett adatkeret","heading":"6 . fejezet Data table: egy továbbfejlesztett adatkeret","text":"Amint volt már róla szó korábban, az adatkeret (data frame) az alapvető struktúra feldolgozandó adatok, adatbázisok tárolására és kezelésére az R-ben. Noha ennek célnak megfelel, számos téren kiegészíthető, továbbfejleszthető. Az évek alatt két nagy lehetőség kristályosodott ki és ment át széleskörű használatba, mely ilyen továbbfejlesztést jelent: dplyr csomag és data.table csomag. Jelen fejezet data.table működését és jellemzőit fogja bemutatni, különös tekintettel hagyományos data frame-mel való összevetésre.data.table csomag első verziója 2008-ban jelent meg, eredeti megalkotója Matt Dowle. Nagyon erőteljes, gyors, erősen optimalizált, némi gyakorlás után logikus, kompakt, konzisztens, könnyen lekódolható és jól olvasható szintaktikájú, jól támogatott csomag. data.table-nek semmilyen függősége nincs az R-en kívül (ott törekednek nagyon régi változatok támogatására ), így kifejezetten problémamentesen beépíthető R kódokba, csomagokba.Központi weboldala: https://rdatatable.gitlab.io/data.table/. Github-oldala: https://github.com/Rdatatable/data.table. CRAN-oldala: https://cran.r-project.org/web/packages/data.table/index.html.data.table mint csomag egy azonos nevű új adatstruktúrát definiál; ez lényegében egy továbbfejlesztett data frame. Ez az új adatstruktúra, data table egyrészt olyan lehetőségeket biztosít, amik valamilyen módon megvalósíthatóak lennének szokásos data frame-mel , de csak lassabban/nehézkesebben/több hibalehetőséggel, másrészt elérhetővé tesz olyan funkciókat , amik data frame-mel egyáltalán nem megoldhatóak.következőkben át fogjuk tekinteni ezek legfontosabb példait.gyakorlati szemléltetésekhez töltsük könyvtárat (data.table nem jön az alap R installációval, így ha korábban nem tettük meg, elsőként telepíteni kell):Ebben fejezetben magyar Nemzeti Rákregiszter adatait fogjuk példa adatbázisnak használni.Elsőként töltsük következő fájlt, ami eleve data.table formátumban tartalmazza az adatokat:Néhány esetben össze fogjuk vetni data.frame-et data.table-lel, ehhez minősítsük vissza az adatbázist data frame-mé, és ezt mentsük el egy új változóba:Érdemes ránézni egy data table felépítésére:Ami feltűnhet, hogy az objektumnak egyaránt van data.table és data.frame osztálya, egyebekben azonban fenti információk megfelelnek egy data frame által mutatott felépítésnek. két osztály jelenléte egyfajta visszafele kompatibilitást3 jelent: egy data table olyan számítógépen betölthető, ahol nincs data.table csomag, és működni fog (természetesen csak mint hagyományos data frame). Ezen túl az igaz ennek következtében, hogy olyan függvénynek, ami data.frame-et vár mindig átadható data.table .Visszatérve tábla felépítésére, fentiek alapján már elmondható, hogy tábla mit tartalmaz: az új rákos esetek előfordulását Magyarországon évenként (2000-től 2018-ig), megyénként, nemenként, életkoronként (ez 5 éves felbontású, tehát 40 igazából azt jelenti, hogy 40-45 év), és rák típusa szerint. Ez utóbbi ún. BNO-kóddal van megadva: Betegségek Nemzetközi Osztályozása (BNO, angol rövidítéssel ICD) egy nemzetközileg egységes rendszer, mely minden betegséghez egy kódot rendel. kód első karaktere egy betű, ez főcsoport; rákos betegségek C főcsoportban, illetve D elején vannak, második és harmadik karakter egy szám, ami konkrét betegséget vagy betegségcsoport azonosít; például C00 az ajak rosszindulatú daganata, C01 nyelvgyök rosszindulatú daganata és így tovább4. Az esetek számát az N nevű változó tartalmazza, háttérpopuláció lélekszámát5, tehát, hogy hány fő volt adott évben, adott megyében, adott nemben, adott életkorban – pedig Population. (Ez tehát azonos lesz azokra sorokra, amelyek csak rák típusában térnek el, hiszen ezekre háttérpopuláció lélekszáma természetesen ugyanaz.)","code":"\nlibrary(data.table)\nRawData <- readRDS(url(paste0(\n  \"https://github.com/tamas-ferenci/RakregiszterVizualizator/\",\n  \"raw/refs/heads/master/RawDataLongWPop.rds\")))\nRawDataDF <- data.frame(RawData)\nstr(RawData)## Classes 'data.table' and 'data.frame':   1313280 obs. of  7 variables:\n##  $ County    : chr  \"Baranya megye\" \"Baranya megye\" \"Baranya megye\" \"Baranya megye\" ...\n##  $ Sex       : chr  \"Férfi\" \"Férfi\" \"Férfi\" \"Férfi\" ...\n##  $ Age       : num  0 0 0 0 0 0 0 0 0 0 ...\n##  $ Year      : num  2000 2000 2000 2000 2000 2000 2000 2000 2000 2000 ...\n##  $ ICDCode   : chr  \"C00\" \"C01\" \"C02\" \"C03\" ...\n##  $ N         : int  0 0 0 0 0 0 0 0 0 0 ...\n##  $ Population: num  9876 9876 9876 9876 9876 ...\n##  - attr(*, \".internal.selfref\")=<externalptr> \n##  - attr(*, \"sorted\")= chr [1:4] \"County\" \"Sex\" \"Age\" \"Year\""},{"path":"data-table-egy-továbbfejlesztett-adatkeret.html","id":"sebesség-és-nagyméretű-adatbázisok-kezelése","chapter":"6 . fejezet Data table: egy továbbfejlesztett adatkeret","heading":"6.1 Sebesség és nagyméretű adatbázisok kezelése","text":"Ez probléma legtöbb szokásos elemzési feladatnál nem jelentkezik, itt sem fogunk rá részletes példát nézni, de röviden érdemes arról megemlékezni, hogy hagyományos adatkeret (data frame) adatstuktúra nem szerencsés, ha nagyméretű adatbázisokat kell kezelnünk.Az első probléma kapásból az adatok beolvasásánál fog jelentkezni: read.csv (és társai) egész egyszerűen lassúak. Pár százezer sorig ennek semmilyen érzékelhető hatása nincsen, mert még így elég gyors beolvasás, így legtöbb feladatnál ez probléma nem jelentkezik, de millió soros, több millió soros adatbázisoknál, ha tábla mérete több gigabájt vagy több tíz gigabájt, akkor beolvasás méret növekedtével gyorsan lassul, míg végül teljesen reménytelenné válik. data.table definiálja az fread függvényt mely ezzel szemben villámgyors, és még ilyen méretű adatok beolvasásánál elfogadható sebességet produkál. (Az fread-nek ezen kívül van pár további előnye az R beépített beolvasó függvényeihez képest, olyan, amik kis méretű adatbázisoknál érdekesek lehetnek, például nagyon okosan detektálja az oszlopelválasztókat és az oszloptípusokat.) Hasonló helyzet kiírásnál: write.csv és társai nagyon nagy adatbázisoknál elfogadhatatlanul lassúak lesznek, de data.table könyvtár fwrite függvénye ilyenkor jól működik.második probléma, hogy még ha valahogy olvastuk az adatbázist memóriába, akkor bajban leszünk az adattranszformációkkal: data frame nincs túl jól optimalizálva ilyen szempontból, egy sor művelet nagyon lassú. Ismét csak: ennek kis, közepes és legtöbb terület mércéje szerinti nagy adatbázisoknál nincs jelentősége, mert még így gyors, de nagyon nagy adatbázisoknál bajban leszünk data frame-et használva. data table ezzel szemben nagyon jól optimalizált, képest többmagú processzoroknál bizonyos műveletek párhuzamos végrehajtására , így az adattranszformációs műveleteknél6 (aggregáció, táblaegyesítések, de akár új változó létrehozása) sokkal jobb sebességet tud produkálni.fentieket többféle benchmark vizsgálat megerősíti.","code":""},{"path":"data-table-egy-továbbfejlesztett-adatkeret.html","id":"jobb-kiíratás","chapter":"6 . fejezet Data table: egy továbbfejlesztett adatkeret","heading":"6.2 Jobb kiíratás","text":"data frame kiíratásánál (tehát ha egyszerűen beírjuk, hogy RawDataDF, ami ekvivalens print(RawDataDF) függvény meghívásával) az alapbeállítás az, hogy kiírja konzolra az első jó sok sorát az adatbázisnak7. Ez nem túl praktikus: az 587. sor ismerete jellemzően nem sokat ad hozzá az első 586-hoz, cserében hosszasan kell görgetnünk rengeteg sor miatt, hogy elérjünk kiíratás tetejére, aminek viszont volna jelentősége, mert ott látjuk az oszlopok neveit. (Nem véletlenül gyakori, hogy sokan eleve head(RawDataDF) típusú kéréssel íratják ki data frame-eket!)data table alapértelmezett kiíratása okosabb, mert csak az első néhány és az utolsó néhány sort8 írja ki:Természetesen láthatóak az oszlopfejlécek (változónevek) , sőt, itt van még egy további apró fejlesztés: data table kiírja az egyes oszlopok adattípusát , standard rövidítéssel.","code":"\nRawData## Key: <County, Sex, Age, Year>\n##                 County    Sex   Age  Year ICDCode     N Population\n##                 <char> <char> <num> <num>  <char> <int>      <num>\n##       1: Baranya megye  Férfi     0  2000     C00     0     9876.0\n##       2: Baranya megye  Férfi     0  2000     C01     0     9876.0\n##       3: Baranya megye  Férfi     0  2000     C02     0     9876.0\n##       4: Baranya megye  Férfi     0  2000     C03     0     9876.0\n##       5: Baranya megye  Férfi     0  2000     C04     0     9876.0\n##      ---                                                          \n## 1313276:    Zala megye     Nő    85  2018     D06     0     4483.5\n## 1313277:    Zala megye     Nő    85  2018     D07     0     4483.5\n## 1313278:    Zala megye     Nő    85  2018     D09     0     4483.5\n## 1313279:    Zala megye     Nő    85  2018     D30     0     4483.5\n## 1313280:    Zala megye     Nő    85  2018     D33     0     4483.5"},{"path":"data-table-egy-továbbfejlesztett-adatkeret.html","id":"kényelmesebb-sorindexelés-sor-szűrés-és--rendezés","chapter":"6 . fejezet Data table: egy továbbfejlesztett adatkeret","heading":"6.3 Kényelmesebb sorindexelés (sor-szűrés és -rendezés)","text":"Data frame indexeléséhez szögletes zárójelet kell írnunk változó neve után, abba vesszőt tennünk, majd vessző elé kerül az sor indexelése. Ezt tipikusan szűréshez használjuk. Például, ha ki akarjuk választani csak 2010-es év adatait:Ez lényegében logikai vektorral indexelés esete: RawDataDF$Year == 2010 egy adatbázissal sorainak számával azonos hosszúságú logikai vektor lesz.Ha ki akarjuk választani 2010 évben 40 évnél idősebbek adatait, akkor logikai ÉS operátort (&) kell használnunk; ez egyúttal azt szemlélteti, hogy feltételek természetesen nem csak egyenlőségek lehetnek:dolog hasonlóan folytatódik, ha további feltételek vannak. Például 2010 évben 40 évnél idősebb budapesti vagy Pest megyei férfiak körében előforduló vastagbélrákos (BNO-kód: C18) esetek kiválasztása:dolog tökéletesen működik, ámde nem túl kényelmes: folyton kell írni RawDataDF$-t feltételek közé. kód hosszú, lassabb megírni, és az olvashatóság romlik. Fontos hangsúlyozni, hogy ez nem hagyható el, és teljesen igaza van az R-nek, hogy nem hagyható el: Year nevű változó nem létezik, tehát teljes joggal ad hibát, ha előle – vagy bármelyik másik elől – elhagyjuk data frame nevét.Mégis: gyakorlatban az esetek 99,99%-ában, ha egy változó nevére hivatkozunk miközben egy adatkeret sorindexelését végezzük, akkor azt természetesen úgy értjük, hogy annak az adatkeretnek az adott nevű oszlopa (és nem egy külső változó). Éppen emiatt data table megengedi ezt szintaktikát: ha pusztán egy változó nevére hivatkozunk, akkor ő megnézi, hogy nincs-e olyan nevű oszlopa az indexelt adattáblának, és ha van, akkor úgy veszi, hogy arra szerettünk volna hivatkozni. Éppen ezért az alábbi kód data.frame-mel nem, de data.table-lel működik:kapott kód világosabb, gyorsabban beírható és jobban olvasható!data table azt megengedi, hogy vesszőt elhagyjuk (data frame nem, ott hibát adna ha nem írnánk vesszőt!):Fontos azonban, hogy ez csak ebben az esetben, tehát sorindexelésnél használható: ha nincs vessző, akkor automatikusan úgy veszi, hogy amit beírtunk, az sorindex (e megállapodás nélkül nem tudhatná, hogy mit akartunk indexelni).tény, hogy nem kell hivatkozni az adatkeret nevére, nem csak szűrésnél igaz, hanem rendezésnél . Ezt ugyanis az order függvény valósítja meg, ami elérhető volt data frame-hez , csak ott ilyen módon kellett használnunk:data table azonban itt megengedi9 fenti – nagyon logikus – egyszerűsítést:Természetesen szűrés és rendezés csak felhasználói szempontból két külön művelet. Az R számára kettő ugyanaz: sorindexelés, csak annyi eltéréssel, hogy az előbbi esetben logikai vektort kap, az utóbbiban pedig számvektort (hiszen az order egyszerűen megadja sorban minden elemre, hogy az adott elem hányadik nagyság szerinti sorrendben).","code":"\nhead(RawDataDF[RawDataDF$Year == 2010,])##            County   Sex Age Year ICDCode N Population\n## 961 Baranya megye Férfi   0 2010     C00 0       9430\n## 962 Baranya megye Férfi   0 2010     C01 0       9430\n## 963 Baranya megye Férfi   0 2010     C02 0       9430\n## 964 Baranya megye Férfi   0 2010     C03 0       9430\n## 965 Baranya megye Férfi   0 2010     C04 0       9430\n## 966 Baranya megye Férfi   0 2010     C05 0       9430\nhead(RawDataDF[RawDataDF$Year == 2010 & RawDataDF$Age >= 40,])##              County   Sex Age Year ICDCode N Population\n## 15553 Baranya megye Férfi  40 2010     C00 0      13076\n## 15554 Baranya megye Férfi  40 2010     C01 0      13076\n## 15555 Baranya megye Férfi  40 2010     C02 0      13076\n## 15556 Baranya megye Férfi  40 2010     C03 0      13076\n## 15557 Baranya megye Férfi  40 2010     C04 0      13076\n## 15558 Baranya megye Férfi  40 2010     C05 0      13076\nhead(RawDataDF[RawDataDF$Year == 2010 &  RawDataDF$Age >= 40 &\n                 RawDataDF$County %in% c(\"Budapest\",\n                                         \"Pest megye\") &\n                 RawDataDF$Sex == \"Férfi\" &\n                 RawDataDF$ICDCode == \"C18\",])##          County   Sex Age Year ICDCode   N Population\n## 146899 Budapest Férfi  40 2010     C18   3    57445.5\n## 148723 Budapest Férfi  45 2010     C18  10    42410.0\n## 150547 Budapest Férfi  50 2010     C18  17    45329.0\n## 152371 Budapest Férfi  55 2010     C18  44    55633.5\n## 154195 Budapest Férfi  60 2010     C18  59    45170.0\n## 156019 Budapest Férfi  65 2010     C18 120    39588.0\nRawData[Year == 2010 & Age >= 40 &\n          County %in% c(\"Budapest\", \"Pest megye\") &\n          Sex == \"Férfi\" & ICDCode == \"C18\",]## Key: <County, Sex, Age, Year>\n##         County    Sex   Age  Year ICDCode     N Population\n##         <char> <char> <num> <num>  <char> <int>      <num>\n##  1:   Budapest  Férfi    40  2010     C18     3    57445.5\n##  2:   Budapest  Férfi    45  2010     C18    10    42410.0\n##  3:   Budapest  Férfi    50  2010     C18    17    45329.0\n##  4:   Budapest  Férfi    55  2010     C18    44    55633.5\n##  5:   Budapest  Férfi    60  2010     C18    59    45170.0\n##  6:   Budapest  Férfi    65  2010     C18   120    39588.0\n##  7:   Budapest  Férfi    70  2010     C18    80    27335.5\n##  8:   Budapest  Férfi    75  2010     C18    75    22253.5\n##  9:   Budapest  Férfi    80  2010     C18    72    15775.5\n## 10:   Budapest  Férfi    85  2010     C18    35    10922.0\n## 11: Pest megye  Férfi    40  2010     C18     8    48086.0\n## 12: Pest megye  Férfi    45  2010     C18     6    36113.5\n## 13: Pest megye  Férfi    50  2010     C18    14    37167.0\n## 14: Pest megye  Férfi    55  2010     C18    32    41154.0\n## 15: Pest megye  Férfi    60  2010     C18    43    32527.0\n## 16: Pest megye  Férfi    65  2010     C18    56    26071.0\n## 17: Pest megye  Férfi    70  2010     C18    62    16926.5\n## 18: Pest megye  Férfi    75  2010     C18    45    11964.5\n## 19: Pest megye  Férfi    80  2010     C18    23     7015.0\n## 20: Pest megye  Férfi    85  2010     C18    11     4250.5\n##         County    Sex   Age  Year ICDCode     N Population\nRawData[Year == 2010 & Age >= 40 &\n          County %in% c(\"Budapest\", \"Pest megye\") &\n          Sex == \"Férfi\" & ICDCode == \"C18\"]## Key: <County, Sex, Age, Year>\n##         County    Sex   Age  Year ICDCode     N Population\n##         <char> <char> <num> <num>  <char> <int>      <num>\n##  1:   Budapest  Férfi    40  2010     C18     3    57445.5\n##  2:   Budapest  Férfi    45  2010     C18    10    42410.0\n##  3:   Budapest  Férfi    50  2010     C18    17    45329.0\n##  4:   Budapest  Férfi    55  2010     C18    44    55633.5\n##  5:   Budapest  Férfi    60  2010     C18    59    45170.0\n##  6:   Budapest  Férfi    65  2010     C18   120    39588.0\n##  7:   Budapest  Férfi    70  2010     C18    80    27335.5\n##  8:   Budapest  Férfi    75  2010     C18    75    22253.5\n##  9:   Budapest  Férfi    80  2010     C18    72    15775.5\n## 10:   Budapest  Férfi    85  2010     C18    35    10922.0\n## 11: Pest megye  Férfi    40  2010     C18     8    48086.0\n## 12: Pest megye  Férfi    45  2010     C18     6    36113.5\n## 13: Pest megye  Férfi    50  2010     C18    14    37167.0\n## 14: Pest megye  Férfi    55  2010     C18    32    41154.0\n## 15: Pest megye  Férfi    60  2010     C18    43    32527.0\n## 16: Pest megye  Férfi    65  2010     C18    56    26071.0\n## 17: Pest megye  Férfi    70  2010     C18    62    16926.5\n## 18: Pest megye  Férfi    75  2010     C18    45    11964.5\n## 19: Pest megye  Férfi    80  2010     C18    23     7015.0\n## 20: Pest megye  Férfi    85  2010     C18    11     4250.5\n##         County    Sex   Age  Year ICDCode     N Population\nhead(RawDataDF[order(RawDataDF$N),])##          County   Sex Age Year ICDCode N Population\n## 1 Baranya megye Férfi   0 2000     C00 0       9876\n## 2 Baranya megye Férfi   0 2000     C01 0       9876\n## 3 Baranya megye Férfi   0 2000     C02 0       9876\n## 4 Baranya megye Férfi   0 2000     C03 0       9876\n## 5 Baranya megye Férfi   0 2000     C04 0       9876\n## 6 Baranya megye Férfi   0 2000     C05 0       9876\nRawData[order(N),]##                 County    Sex   Age  Year ICDCode     N Population\n##                 <char> <char> <num> <num>  <char> <int>      <num>\n##       1: Baranya megye  Férfi     0  2000     C00     0     9876.0\n##       2: Baranya megye  Férfi     0  2000     C01     0     9876.0\n##       3: Baranya megye  Férfi     0  2000     C02     0     9876.0\n##       4: Baranya megye  Férfi     0  2000     C03     0     9876.0\n##       5: Baranya megye  Férfi     0  2000     C04     0     9876.0\n##      ---                                                          \n## 1313276:      Budapest     Nő    60  2008     C50   307    64674.0\n## 1313277:      Budapest     Nő    55  2000     C50   308    67218.5\n## 1313278:      Budapest     Nő    55  2002     C50   308    69118.0\n## 1313279:      Budapest     Nő    70  2018     C44   331    56508.0\n## 1313280:      Budapest     Nő    55  2003     C50   350    69396.5"},{"path":"data-table-egy-továbbfejlesztett-adatkeret.html","id":"kibővített-oszlopindexelés-oszlop-kiválasztás-és-oszlop-létrehozás-műveletekkel","chapter":"6 . fejezet Data table: egy továbbfejlesztett adatkeret","heading":"6.4 Kibővített oszlopindexelés: oszlop-kiválasztás és oszlop-létrehozás műveletekkel","text":"Hagyományos data frame esetén vessző után jön az oszlopindexelés, ami egy dolgot jelenthet: oszlopok kiválasztását. Tehát, dönthetünk, hogy mely oszlopokat kérjük (és melyeket nem), de más lehetőségünk nincs. Oszlopok kiválasztását célszerű mindig névvel és nem számmal végeznünk (hogy kód az adatbázis esetleges későbbi módosításaira robusztusabb legyen, ne romoljon el új oszlop beszúrásától vagy törlésétől, valamint, hogy önállóan jobban olvasható legyen kód). Ekkor lényegében egy sztring-vektort kell átadnunk. példa kedvéért itt – az előzőekkel szemben – 40-45 éves budapesti férfiak vastagbélrákos eseteire szorítsuk meg magunkat, viszont tartsuk meg az összes évet. Ez esetben logikus csak az évet – és persze az N-et és Population-t – kiíratni, hiszen többi konstans:Ez szintaktika data.table-lel működik10:data.table-nek van azonban egy saját, külön szintaktikája erre, és célszerű azt megszokni és használni mindig, mert későbbi funkciókat az teszi elérhetővé:Megjegyzendő, hogy . egyszerűen egy rövidítés, amit data.table csomag bevezet arra, hogy list, magyarán itt az történik, hogy egy listát kell átadnunk11, benne az – idézőjelek nélküli – oszlopnevekkel. listás megoldás előnye, hogy valójában nem kötelező explicite kiírni, hogy . majd felsorolni változóneveket zárójelben, bármilyen függvényt használhatunk vessző után ami listát ad eredményül. Később látunk majd erre példát.Az érthető listás megoldás fényében, hogy data table-lel átnevezhetünk változót úgymond menet közben (data frame-mel már ezt sem lehetett!):Ez már utat mutat következő, igazi újdonsághoz.Előtte még említsük meg, hogy data table egyik jellegzetessége, hogy RawData[, .(Year)] típusú hívások mindig data table-t adnak vissza12. Ha egyetlen változót választunk ki, de azt vektorként szeretnénk visszakapni (ez kérdés nyilván csak egyetlen változó kiválasztásakor merül fel), akkor használjuk RawData$Year vagy RawData[[\"Year\"]] formát13.Ez eddig nem nagy változás, még csak azt sem igazán lehet mondani, hogy az előzőhöz hasonló kényelmi továbbfejlesztés, hiszen ez szintaktika nem sokkal tér el korábbitól. Az igazán érdekes rész azonban jön, data.table ugyanis lehetővé tesz valamit, ami data.frame-nél fel sem merült: nem csak passzívan kiválaszthatunk oszlopokat, hanem műveleteket végezhetünk velük, így új oszlopokat hozva létre! Lényegében fly, azaz menet közben végezhetünk műveleteket és hozhatunk létre új oszlopokat, anélkül, hogy azokat fizikailag le kellene tárolnunk az adatbázisba. data table vessző utáni pozíciójában tehátPéldául rákos megbetegedéseknél fontos az incidencia, tehát lélekszámhoz viszonyított előfordulás. (Értelemszerűen nem mindegy, hogy 10 vagy 10 ezer ember közül került ki 1 rákos adott évben.) Ezt tipikusan 100 ezer lakosra vonatkoztatva szokták megadni. Nézzük meg következő data table-t használó megoldást:Azaz az Inc oszlopot létrehoztuk nélkül, hogy előzetesen azt le kellett volna tárolnunk magába az adatbázisba! Menet közben számoltuk ki, és még nevet adtunk neki. Az oszlopok tehát itt, vessző utáni pozícióban úgy viselkednek egy data table-nél mintha szokásos változók lennének!Ebből adódik, hogy lehetőségeink még ennél bővebbek: nem csak egyszerű aritmetikai műveleteket végezhetünk egy oszloppal (vagy épp több oszloppal! – mint arra ez előbbi kód példát mutat), hanem bármilyen R függvényt rájuk ereszthetünk! Tekintsünk példának következő kódot, mely megadja, hogy 40-45 éves budapesti férfiak körében összesen hány vastagbélrákos eset volt az adatbázis által lefedett 19 év alatt:Az N oszlop egy vektor, tehát azon túl, hogy oszthatjuk – elemenként – egy másik vektorral, mint ahogy az előbbi esetben tettük, nyugodtan összegezhetjük példának okáért. Ebből mellesleg az látszik, hogy még az sem jelent problémát, ha művelet által visszaadott eredménynek hossza eltér bemenő változóétól! Hiszen sum(N) 1 hosszú, míg Year 19. (Az azonban fontos, hogy itt már Year nem szerepel kiválasztott oszlopok között: megtarthattuk volna Year-t , de mivel az 19 hosszú, így mellette lévő oszlopban ugyanaz az összeg 19-szer meg lett volna ismételve.)fenti példákban egyszerre szűrtünk sorokat és számoltunk oszlopokat. (Ez természetesen nem kötelező, lehet csak az egyiket csinálni másik nélkül.) Egyetlen példa data.table optimalizálására: ilyenkor nem azt csinálja, hogy leszűri az egész adatbázist, és aztán végzi az oszlopműveleteket, hanem először megnézi, hogy mely oszlopokra van egyáltalán szükség – például csak Year-re, N-re és Population-re – és ilyenkor csak azokat szűri le, így kerülve el, hogy olyan oszlopok szűrését el kelljen végeznie, amik később nem jelennek meg az eredményben. Ez azért lehetséges, mert data.table egyben látja az egész feladatot, és így tud ilyen optimalizálásokat tenni.Visszatérve, dolog még jobban kombinálható: legyen példa kedvéért feladatunk az, hogy számoljuk ki az egész 19 éves periódusra az incidenciát. (Egy pillanatra érdemes itt megállni, és végiggondolni, hogy mi egyáltalán az ehhez szükséges művelet!) Íme megvalósítás data.table használatával:Amint láthatjuk, tetszőleges komplexitású műveletet, számítást elvégezhetünk vessző után! És ezt szó szerint kell érteni: bármilyen R függvényt használhatunk az oszlopindexelés pozíciójában, vessző után, bármilyen műveletet vagy számítást végezhetünk (tehát még csak olyan megkötés sincs, hogy csak bizonyos függvényeket, műveleteket tesz csak elérhetővé data.table). Íme egy példa; lognormális eloszlást illesztünk az esetszámok különböző években mért értékeiből kapott eloszlásra:Szépen látszik itt , hogy nyugodtan használhatjuk az N-et csak így, minden további nélkül – ugyanúgy viselkedik, mint egy szokásos változó, ugyanúgy használhatjuk egy számítás során.Ráadásul, ha visszaemlékszünk, akkor szerepelt, hogy vessző utáni pozícióban egy listának kell szerepelnie – de ezt előállíthatja egy függvény ! Például fitdistrplus::fitdist eredményének estimate nevű komponense egy vektor. De ha ez .list-tel átalakítjuk, akkor egy listát kapunk, így közvetlenül átadható vessző utáni pozícióban (természetesen ilyenkor . nem kell, hiszen az .list eleve egy listát ad vissza!):Ez tehát már messze-messze nem csak egyszerűen oszlopkiválasztás, amire itt módunk van, ha data.table-t használunk.Egyetlen megjegyzés végére: mi van akkor, ha kíváncsiak vagyunk arra, hogy hány sor van egy adattáblában (esetleg szűkítés után)? RawData[Age == 40 & County == \"Budapest\" & Sex == \"Férfi\" & ICDCode == \"C18\", length(N)] kézenfekvő megoldás, de nem túl elegáns (miért pont az N hosszát néztük meg? bármi más ugyanezt az eredményt adná!). Erre célra data.table bevezet egy speciális szimbólumot, .N-et, ami egyszerűen visszaadja14 sorok számát:","code":"\nhead(RawDataDF[RawDataDF$Age == 40 &\n                 RawDataDF$County == \"Budapest\" &\n                 RawDataDF$Sex == \"Férfi\" &\n                 RawDataDF$ICDCode == \"C18\",\n               c(\"Year\", \"N\", \"Population\")])##        Year N Population\n## 145939 2000 8    51602.0\n## 146035 2001 4    47836.0\n## 146131 2002 4    45296.5\n## 146227 2003 4    43632.5\n## 146323 2004 4    43085.0\n## 146419 2005 5    43442.5\nRawData[Age == 40 & County == \"Budapest\" & Sex == \"Férfi\" &\n          ICDCode == \"C18\",\n        c(\"Year\", \"N\", \"Population\")]##      Year     N Population\n##     <num> <int>      <num>\n##  1:  2000     8    51602.0\n##  2:  2001     4    47836.0\n##  3:  2002     4    45296.5\n##  4:  2003     4    43632.5\n##  5:  2004     4    43085.0\n##  6:  2005     5    43442.5\n##  7:  2006     5    44511.5\n##  8:  2007     6    46903.5\n##  9:  2008     4    50505.5\n## 10:  2009     6    54015.0\n## 11:  2010     3    57445.5\n## 12:  2011     8    60721.0\n## 13:  2012     7    62471.5\n## 14:  2013     5    63746.5\n## 15:  2014     8    66250.5\n## 16:  2015    13    70511.5\n## 17:  2016    11    74622.0\n## 18:  2017     6    77902.0\n## 19:  2018    10    80555.0\nRawData[Age == 40 & County == \"Budapest\" & Sex == \"Férfi\" &\n          ICDCode == \"C18\",\n        .(Year, N, Population)]##      Year     N Population\n##     <num> <int>      <num>\n##  1:  2000     8    51602.0\n##  2:  2001     4    47836.0\n##  3:  2002     4    45296.5\n##  4:  2003     4    43632.5\n##  5:  2004     4    43085.0\n##  6:  2005     5    43442.5\n##  7:  2006     5    44511.5\n##  8:  2007     6    46903.5\n##  9:  2008     4    50505.5\n## 10:  2009     6    54015.0\n## 11:  2010     3    57445.5\n## 12:  2011     8    60721.0\n## 13:  2012     7    62471.5\n## 14:  2013     5    63746.5\n## 15:  2014     8    66250.5\n## 16:  2015    13    70511.5\n## 17:  2016    11    74622.0\n## 18:  2017     6    77902.0\n## 19:  2018    10    80555.0\nRawData[Age == 40 & County == \"Budapest\" & Sex == \"Férfi\" &\n          ICDCode == \"C18\",\n        .(Year, Esetszam = N, Lelekszam = Population)]##      Year Esetszam Lelekszam\n##     <num>    <int>     <num>\n##  1:  2000        8   51602.0\n##  2:  2001        4   47836.0\n##  3:  2002        4   45296.5\n##  4:  2003        4   43632.5\n##  5:  2004        4   43085.0\n##  6:  2005        5   43442.5\n##  7:  2006        5   44511.5\n##  8:  2007        6   46903.5\n##  9:  2008        4   50505.5\n## 10:  2009        6   54015.0\n## 11:  2010        3   57445.5\n## 12:  2011        8   60721.0\n## 13:  2012        7   62471.5\n## 14:  2013        5   63746.5\n## 15:  2014        8   66250.5\n## 16:  2015       13   70511.5\n## 17:  2016       11   74622.0\n## 18:  2017        6   77902.0\n## 19:  2018       10   80555.0\nRawData[Age == 40 & County == \"Budapest\" & Sex == \"Férfi\" &\n          ICDCode == \"C18\",\n        .(Year, N, Population, Inc = N / Population * 1e5)]##      Year     N Population       Inc\n##     <num> <int>      <num>     <num>\n##  1:  2000     8    51602.0 15.503275\n##  2:  2001     4    47836.0  8.361903\n##  3:  2002     4    45296.5  8.830704\n##  4:  2003     4    43632.5  9.167478\n##  5:  2004     4    43085.0  9.283974\n##  6:  2005     5    43442.5 11.509467\n##  7:  2006     5    44511.5 11.233052\n##  8:  2007     6    46903.5 12.792222\n##  9:  2008     4    50505.5  7.919930\n## 10:  2009     6    54015.0 11.108026\n## 11:  2010     3    57445.5  5.222341\n## 12:  2011     8    60721.0 13.175014\n## 13:  2012     7    62471.5 11.205110\n## 14:  2013     5    63746.5  7.843568\n## 15:  2014     8    66250.5 12.075381\n## 16:  2015    13    70511.5 18.436709\n## 17:  2016    11    74622.0 14.740961\n## 18:  2017     6    77902.0  7.701985\n## 19:  2018    10    80555.0 12.413879\nRawData[Age == 40 & County == \"Budapest\" & Sex == \"Férfi\" &\n          ICDCode == \"C18\",\n        .(N = sum(N))]##        N\n##    <int>\n## 1:   121\nRawData[Age == 40 & County == \"Budapest\" & Sex == \"Férfi\" &\n          ICDCode == \"C18\",\n        .(Inc = sum(N) / sum(Population) * 1e5)]##        Inc\n##      <num>\n## 1: 11.1515\nRawData[Age == 40 & County == \"Budapest\" & Sex == \"Férfi\" &\n          ICDCode == \"C18\",\n        .(fitdistrplus::fitdist(N, \"lnorm\")$estimate[\"meanlog\"])]##          V1\n##       <num>\n## 1: 1.772807\nRawData[Age == 40 & County == \"Budapest\" & Sex == \"Férfi\" &\n          ICDCode == \"C18\",\n        as.list(fitdistrplus::fitdist(N, \"lnorm\")$estimate)]##     meanlog     sdlog\n##       <num>     <num>\n## 1: 1.772807 0.3902478\nRawData[Age == 40 & County == \"Budapest\" & Sex == \"Férfi\" &\n          ICDCode == \"C18\", .N]## [1] 19"},{"path":"data-table-egy-továbbfejlesztett-adatkeret.html","id":"csoportosítás-aggregáció","chapter":"6 . fejezet Data table: egy továbbfejlesztett adatkeret","heading":"6.5 Csoportosítás (aggregáció)","text":"data.table második, rendkívül erőteljes bővítése hagyományos data frame funkcionalitásához képest csoportosítás (aggregáció) lehetősége. data.table bevezet egy harmadik pozíciót szögletes zárójelen belül: megtehetjük, hogy két vesszőt teszünk ki szögletes zárójelen belül, ez esetben az első vessző előtt van sorindexelés (ahogy eddig ), az első és második vessző között az oszlopkiválasztás és -számítás (ahogy eddig ), viszont második vessző után megadhatunk egy listát egy vagy több változóból. (. ugyanúgy használható list helyett. Megadhatunk sztring-vektort , benne változók neveivel; ez különösen jól jön akkor, ha gépi úton állítjuk elő, hogy mik ezek változók.) Mi fog ilyenkor történni? data.table elsőként végrehajtja sorok szűrését, ha kértünk ilyet, ezután pedig az új, harmadik pozícióban megadott változó vagy változók szerint csoportokat képez. Mit jelent az, hogy csoport? Azok sorai táblának, amelyekben csoportosító változó egy adott értéket vesz fel: ahány lehetséges értéke van csoportosító változónak táblában, annyi csoport képződik, úgy, hogy csoporton belül csoportosító változó homogén lesz. Ezt követően data.table végrehajtja megadott oszlopkiválasztásokat és/vagy oszlopműveleteket csoportonként külön-külön, végül pedig kapott eredményeket újra összerakja egy táblába, úgy, hogy mindegyik csoport eredménye mellé beteszi oszlopként azt, hogy ott mi volt csoportosító változó értéke. Az egyes csoportok abban sorrendben fognak szerepelni az eredményben, ahogy egymás után jöttek kiinduló táblában.jobb megértés kedvéért nézzünk egy gyakorlati példát! Kíváncsiak vagyunk az egész időintervallumra vonatkozó incidenciára, de az összes rák-típus esetén külön-külön megadva. Mit tudunk tenni? Fent láttuk kódot, mely egy adott típusra ezt kiszámolja. Az remélhetőleg senkinek nem jut az eszébe, hogy kézzel lefuttassa először C00-val, aztán C01-gyel, aztán C02-vel… Működőképesebb megoldás ennek valamilyen R paranccsal történő automatizálása. Rosszabb esetben jut az eszünkbe, jobb esetben az apply család valamely tagja. (-ciklus rosszabb eset, mert az R-ben legtöbb esetben illendő kerülni, és jelen esetben tényleg meg oldható probléma megfelelő apply használatával, így ez célszerű választás.) Ha azonban data.table-t használjuk, akkor még csak erre sincs szükség!Nézzük ugyanis meg következő hívást:Mi történt itt? Először , sor-szűrések közül kivettük konkrét rák-típust – ez értelemszerű, hiszen az összes ráktípusra vonatkozó adatot szeretnénk kapni, épp ez volt feladat, tehát ebben nyilván nem szűrhetjük le előzetesen az adatbázist. Másodszor, bekerült harmadik pozíciója, csoportosító változóként rák típusa. Mit jelent ez? Azt, hogy szűrés után data.table leszűrt adatbázisból rák-típus szerint csoportokat képez, tehát szétszedi az adatbázist kis táblákra úgy, hogy mindegyikben egy adott rák-típus adatai legyenek, mindegyikre elvégzi második pozícióban, az oszlopindexelésnél megadott műveleteket (jelen esetben: kiszámítja az incidenciákat), majd ezeket az eredményeket, ami itt egyetlen sor lesz, újra összerakja egy nagy táblába, jelezve, hogy az adott eredmény melyik kódhoz tartozik.Nagyon szájbarágós, de talán egyszer érdemes dolgot megnézni lépésről-lépésre. data.table elsőként leszűri táblát sorindex szerint:Ezt követően megnézi, hogy csoportosító változó milyen értékeket vesz fel:Majd ezek mindegyikére leszűkíti (szűrt) táblát, lényegében kis táblákat készítve. Így néz ki C00-hoz tartozó:Így C01-hez:És így tovább.Ezt követően minden kis táblára elvégzi az oszlopindexelésnél kijelölt műveletet. Így fog kinézni az eredmény C00-s kis táblára:Így C01-es kis táblára:Majd ezeket kis táblákat egymás alá rendezi, abban sorrendben, ahogy az eredeti táblában előfordultak csoportosító változó értékei, és úgy, hogy mindegyikhez melléírja, hogy az adottnál mi volt csoportosító változó értéke, tehát jelen esetben, hogy melyik ráktípushoz tartozik.Így kaptuk fent látható táblát (menjünk vissza és ellenőrizzük)…!Nézzünk meg – már nagyon részletes levezetés nélkül – még egy példát csoportosításra. Kíváncsiak vagyunk egy adott ráktípus korspecifikus incidenciájára, tehát, hogy mennyi az incidencia adott életkorban. Ha mindezt rögzített évre, nemre és megyére kérdezzük, akkor célt érhetünk így:dolog azonban nagyon nem szerencsés: kizárólag azért fog működni, mert leszűkítés után egy adott életkorhoz már csak egyetlen sor tartozik. De ha ez nem így lenne, például kitörlünk valamit feltételek közül, akkor teljesen rossz eredményt fog adni, hiszen ilyenkor ugyanaz az életkor többször fog megjelenni az eredményben, míg nekünk össze kellene adnunk az adott életkorhoz tartozó különböző megfigyeléseket.megoldás csoportosítás az életkor szerint, és az összeadás adott életkoron belül:Ez immár működik másféle szűréssel , például ha Budapest helyett az egész országra vagyunk kíváncsiak:Érdemes végiggondolni (ez általában hasznos): ilyenkor az életkor szerinti kis táblákban 20 sor lesz – az egyes megyékkel – és ezek fölött fogunk összegezni.Megjegyzendő, hogy csoportosító változónak nevet adhatunk:Ami azonban sokkal izgalmasabb, hogy műveletet végezhetünk! Itt igaz, hogy nem kell változót külön letárolni, hanem menet közben kiszámolhatjuk, majd építhetünk rá rögtön (jelen esetben egy csoportosítást). Például, ha ki akarjuk számolni az incidenciát külön 70 év alattiak és felettiek körében:","code":"\nRawData[Age == 40 & County == \"Budapest\" & Sex == \"Férfi\",\n        .(Inc = sum(N) / sum(Population) * 1e5),\n        .(ICDCode)]##     ICDCode         Inc\n##      <char>       <num>\n##  1:     C00  0.36864474\n##  2:     C01  2.21186843\n##  3:     C02  2.58051316\n##  4:     C03  1.01377303\n##  5:     C04  2.48835198\n##  6:     C05  0.73728948\n##  7:     C06  0.55296711\n##  8:     C07  0.92161184\n##  9:     C08  0.73728948\n## 10:     C09  1.65890132\n## 11:     C10  3.13348027\n## 12:     C11  1.19809540\n## 13:     C12  0.46080592\n## 14:     C13  4.42373685\n## 15:     C14  0.82945066\n## 16:     C15  4.14725330\n## 17:     C16  6.72776646\n## 18:     C17  1.75106250\n## 19:     C18 11.15150331\n## 20:     C19  2.58051316\n## 21:     C20  7.09641120\n## 22:     C21  0.55296711\n## 23:     C22  3.87076974\n## 24:     C23  1.01377303\n## 25:     C24  1.47457895\n## 26:     C25  7.37289475\n## 27:     C26  0.46080592\n## 28:     C30  0.64512829\n## 29:     C31  1.10593421\n## 30:     C32  7.46505593\n## 31:     C33  0.09216118\n## 32:     C34 30.78183558\n## 33:     C37  0.46080592\n## 34:     C38  1.10593421\n## 35:     C39  0.36864474\n## 36:     C40  1.01377303\n## 37:     C41  2.94915790\n## 38:     C43 17.41846385\n## 39:     C44 43.13143429\n## 40:     C45  0.64512829\n## 41:     C46  0.46080592\n## 42:     C47  0.00000000\n## 43:     C48  2.39619079\n## 44:     C49 10.78285857\n## 45:     C50  2.76483553\n## 46:     C51  0.00000000\n## 47:     C52  0.00000000\n## 48:     C53  0.00000000\n## 49:     C54  0.00000000\n## 50:     C55  0.00000000\n## 51:     C56  0.00000000\n## 52:     C57  0.00000000\n## 53:     C58  0.00000000\n## 54:     C60  0.92161184\n## 55:     C61  2.94915790\n## 56:     C62 22.11868425\n## 57:     C63  0.64512829\n## 58:     C64 12.25743752\n## 59:     C65  0.27648355\n## 60:     C66  0.00000000\n## 61:     C67  8.38666778\n## 62:     C68  0.18432237\n## 63:     C69  1.10593421\n## 64:     C70  0.55296711\n## 65:     C71  8.75531252\n## 66:     C72  1.10593421\n## 67:     C73  5.06886514\n## 68:     C74  0.73728948\n## 69:     C75  0.27648355\n## 70:     C76  2.67267435\n## 71:     C80  2.39619079\n## 72:     C81  3.40996382\n## 73:     C82  2.58051316\n## 74:     C83  3.96293093\n## 75:     C84  0.92161184\n## 76:     C85  4.42373685\n## 77:     C88  0.00000000\n## 78:     C90  2.21186843\n## 79:     C91  3.31780264\n## 80:     C92  4.51589803\n## 81:     C93  0.00000000\n## 82:     C94  0.18432237\n## 83:     C95  0.09216118\n## 84:     C96  1.56674013\n## 85:     C97  0.00000000\n## 86:     D00  0.46080592\n## 87:     D01  0.18432237\n## 88:     D02  0.09216118\n## 89:     D03  4.60805922\n## 90:     D04  1.75106250\n## 91:     D05  0.00000000\n## 92:     D06  0.00000000\n## 93:     D07  0.36864474\n## 94:     D09  0.27648355\n## 95:     D30  1.38241777\n## 96:     D33  6.26696054\n##     ICDCode         Inc\nRawData[Age == 40 & County == \"Budapest\" & Sex == \"Férfi\"]## Key: <County, Sex, Age, Year>\n##         County    Sex   Age  Year ICDCode     N Population\n##         <char> <char> <num> <num>  <char> <int>      <num>\n##    1: Budapest  Férfi    40  2000     C00     1      51602\n##    2: Budapest  Férfi    40  2000     C01     6      51602\n##    3: Budapest  Férfi    40  2000     C02     2      51602\n##    4: Budapest  Férfi    40  2000     C03     1      51602\n##    5: Budapest  Férfi    40  2000     C04     2      51602\n##   ---                                                     \n## 1820: Budapest  Férfi    40  2018     D06     0      80555\n## 1821: Budapest  Férfi    40  2018     D07     0      80555\n## 1822: Budapest  Férfi    40  2018     D09     2      80555\n## 1823: Budapest  Férfi    40  2018     D30     0      80555\n## 1824: Budapest  Férfi    40  2018     D33     4      80555\nunique(RawData[Age == 40 & County == \"Budapest\" &\n                 Sex == \"Férfi\"]$ICDCode)##  [1] \"C00\" \"C01\" \"C02\" \"C03\" \"C04\" \"C05\" \"C06\" \"C07\" \"C08\" \"C09\" \"C10\" \"C11\"\n## [13] \"C12\" \"C13\" \"C14\" \"C15\" \"C16\" \"C17\" \"C18\" \"C19\" \"C20\" \"C21\" \"C22\" \"C23\"\n## [25] \"C24\" \"C25\" \"C26\" \"C30\" \"C31\" \"C32\" \"C33\" \"C34\" \"C37\" \"C38\" \"C39\" \"C40\"\n## [37] \"C41\" \"C43\" \"C44\" \"C45\" \"C46\" \"C47\" \"C48\" \"C49\" \"C50\" \"C51\" \"C52\" \"C53\"\n## [49] \"C54\" \"C55\" \"C56\" \"C57\" \"C58\" \"C60\" \"C61\" \"C62\" \"C63\" \"C64\" \"C65\" \"C66\"\n## [61] \"C67\" \"C68\" \"C69\" \"C70\" \"C71\" \"C72\" \"C73\" \"C74\" \"C75\" \"C76\" \"C80\" \"C81\"\n## [73] \"C82\" \"C83\" \"C84\" \"C85\" \"C88\" \"C90\" \"C91\" \"C92\" \"C93\" \"C94\" \"C95\" \"C96\"\n## [85] \"C97\" \"D00\" \"D01\" \"D02\" \"D03\" \"D04\" \"D05\" \"D06\" \"D07\" \"D09\" \"D30\" \"D33\"\nRawData[Age == 40 & County == \"Budapest\" & Sex == \"Férfi\" &\n          ICDCode == \"C00\"]## Key: <County, Sex, Age, Year>\n##       County    Sex   Age  Year ICDCode     N Population\n##       <char> <char> <num> <num>  <char> <int>      <num>\n##  1: Budapest  Férfi    40  2000     C00     1    51602.0\n##  2: Budapest  Férfi    40  2001     C00     1    47836.0\n##  3: Budapest  Férfi    40  2002     C00     0    45296.5\n##  4: Budapest  Férfi    40  2003     C00     0    43632.5\n##  5: Budapest  Férfi    40  2004     C00     0    43085.0\n##  6: Budapest  Férfi    40  2005     C00     0    43442.5\n##  7: Budapest  Férfi    40  2006     C00     0    44511.5\n##  8: Budapest  Férfi    40  2007     C00     0    46903.5\n##  9: Budapest  Férfi    40  2008     C00     0    50505.5\n## 10: Budapest  Férfi    40  2009     C00     0    54015.0\n## 11: Budapest  Férfi    40  2010     C00     0    57445.5\n## 12: Budapest  Férfi    40  2011     C00     1    60721.0\n## 13: Budapest  Férfi    40  2012     C00     1    62471.5\n## 14: Budapest  Férfi    40  2013     C00     0    63746.5\n## 15: Budapest  Férfi    40  2014     C00     0    66250.5\n## 16: Budapest  Férfi    40  2015     C00     0    70511.5\n## 17: Budapest  Férfi    40  2016     C00     0    74622.0\n## 18: Budapest  Férfi    40  2017     C00     0    77902.0\n## 19: Budapest  Férfi    40  2018     C00     0    80555.0\nRawData[Age == 40 & County == \"Budapest\" & Sex == \"Férfi\" &\n          ICDCode == \"C01\"]## Key: <County, Sex, Age, Year>\n##       County    Sex   Age  Year ICDCode     N Population\n##       <char> <char> <num> <num>  <char> <int>      <num>\n##  1: Budapest  Férfi    40  2000     C01     6    51602.0\n##  2: Budapest  Férfi    40  2001     C01     1    47836.0\n##  3: Budapest  Férfi    40  2002     C01     0    45296.5\n##  4: Budapest  Férfi    40  2003     C01     3    43632.5\n##  5: Budapest  Férfi    40  2004     C01     2    43085.0\n##  6: Budapest  Férfi    40  2005     C01     0    43442.5\n##  7: Budapest  Férfi    40  2006     C01     3    44511.5\n##  8: Budapest  Férfi    40  2007     C01     2    46903.5\n##  9: Budapest  Férfi    40  2008     C01     0    50505.5\n## 10: Budapest  Férfi    40  2009     C01     2    54015.0\n## 11: Budapest  Férfi    40  2010     C01     0    57445.5\n## 12: Budapest  Férfi    40  2011     C01     3    60721.0\n## 13: Budapest  Férfi    40  2012     C01     1    62471.5\n## 14: Budapest  Férfi    40  2013     C01     1    63746.5\n## 15: Budapest  Férfi    40  2014     C01     0    66250.5\n## 16: Budapest  Férfi    40  2015     C01     0    70511.5\n## 17: Budapest  Férfi    40  2016     C01     0    74622.0\n## 18: Budapest  Férfi    40  2017     C01     0    77902.0\n## 19: Budapest  Férfi    40  2018     C01     0    80555.0\nRawData[Age == 40 & County == \"Budapest\" & Sex == \"Férfi\" &\n          ICDCode == \"C00\",\n        .(Inc = sum(N) / sum(Population) * 1e5)]##          Inc\n##        <num>\n## 1: 0.3686447\nRawData[Age == 40 & County == \"Budapest\" & Sex == \"Férfi\" &\n          ICDCode == \"C01\",\n        .(Inc = sum(N) / sum(Population) * 1e5)]##         Inc\n##       <num>\n## 1: 2.211868\nRawData[Year == 2010 & County == \"Budapest\" &\n          Sex == \"Férfi\" & ICDCode == \"C18\",\n        .(Age, Inc = N / Population * 1e5)]##       Age        Inc\n##     <num>      <num>\n##  1:     0   0.000000\n##  2:     5   0.000000\n##  3:    10   0.000000\n##  4:    15   0.000000\n##  5:    20   1.960054\n##  6:    25   3.072716\n##  7:    30   2.321088\n##  8:    35  11.088472\n##  9:    40   5.222341\n## 10:    45  23.579344\n## 11:    50  37.503585\n## 12:    55  79.089038\n## 13:    60 130.617667\n## 14:    65 303.122158\n## 15:    70 292.659728\n## 16:    75 337.025636\n## 17:    80 456.403917\n## 18:    85 320.454129\nRawData[Year == 2010 & County == \"Budapest\" &\n          Sex == \"Férfi\" & ICDCode == \"C18\",\n        .(Inc = sum(N) / sum(Population) * 1e5), .(Age)]##       Age        Inc\n##     <num>      <num>\n##  1:     0   0.000000\n##  2:     5   0.000000\n##  3:    10   0.000000\n##  4:    15   0.000000\n##  5:    20   1.960054\n##  6:    25   3.072716\n##  7:    30   2.321088\n##  8:    35  11.088472\n##  9:    40   5.222341\n## 10:    45  23.579344\n## 11:    50  37.503585\n## 12:    55  79.089038\n## 13:    60 130.617667\n## 14:    65 303.122158\n## 15:    70 292.659728\n## 16:    75 337.025636\n## 17:    80 456.403917\n## 18:    85 320.454129\nRawData[Year == 2010 & Sex == \"Férfi\" & ICDCode == \"C18\",\n        .(Inc = sum(N) / sum(Population) * 1e5), .(Age)]##       Age         Inc\n##     <num>       <num>\n##  1:     0   0.4013437\n##  2:     5   0.0000000\n##  3:    10   0.3909763\n##  4:    15   0.3278087\n##  5:    20   1.2121488\n##  6:    25   2.2652654\n##  7:    30   3.2732344\n##  8:    35   7.1454000\n##  9:    40  11.2810011\n## 10:    45  21.7613797\n## 11:    50  46.2794518\n## 12:    55  94.8719665\n## 13:    60 130.8683356\n## 14:    65 246.5976935\n## 15:    70 293.1432072\n## 16:    75 367.2073711\n## 17:    80 347.1158754\n## 18:    85 323.4103513\nRawData[Year == 2010 & Sex == \"Férfi\" & ICDCode == \"C18\",\n        .(Inc = sum(N) / sum(Population) * 1e5),\n        .(Eletkor = Age)]##     Eletkor         Inc\n##       <num>       <num>\n##  1:       0   0.4013437\n##  2:       5   0.0000000\n##  3:      10   0.3909763\n##  4:      15   0.3278087\n##  5:      20   1.2121488\n##  6:      25   2.2652654\n##  7:      30   3.2732344\n##  8:      35   7.1454000\n##  9:      40  11.2810011\n## 10:      45  21.7613797\n## 11:      50  46.2794518\n## 12:      55  94.8719665\n## 13:      60 130.8683356\n## 14:      65 246.5976935\n## 15:      70 293.1432072\n## 16:      75 367.2073711\n## 17:      80 347.1158754\n## 18:      85 323.4103513\nRawData[Year == 2010 & Sex == \"Férfi\" & ICDCode == \"C18\",\n        .(Inc = sum(N) / sum(Population) * 1e5),\n        .(Idos = Age > 70)]##      Idos       Inc\n##    <lgcl>     <num>\n## 1:  FALSE  43.83737\n## 2:   TRUE 352.54419"},{"path":"data-table-egy-továbbfejlesztett-adatkeret.html","id":"indexelések-láncolása-egymás-után","chapter":"6 . fejezet Data table: egy továbbfejlesztett adatkeret","heading":"6.6 Indexelések láncolása egymás után","text":"data.table következő újítása, hogy megengedi egy már indexelt tábla (RawData[...]) újabb indexelését. Tehát használhatjuk RawData[...][...] alakot, ahol második indexelés pontosan ugyanúgy fog viselkedni, mint az első (ugyanúgy használhatunk sorindexelést, szűrést és rendezést, oszlopkiválasztást és -transzformációt, csoportosítást), de úgy, hogy az az első, már indexelt táblára vonatkozik! Lényegében mintha elmentettük volna RawData[...]-t egy változóba, és utána azt változót indexelnénk szokásos módon – csak itt nem kell semmit külön elmenteni. Az, hogy második indexelés már az első indexelésben átalakított táblára vonatkozik, egy kritikusan fontos előny, amint az rögtön világossá fog válni.Ha pontosak akarunk lenni, akkor ezt az egymás utáni többszöri indexelést igazából hagyományos data frame megengedi, tehát például RawDataDF[101:200,][5:15,] egy teljesen szabályos hívás (és természetesen egyenértékű lesz azzal, hogy RawDataDF[105:115,]). probléma az, hogy használhatósága nagyon korlátozott, mert második indexben, ha változóra hivatkozunk, az az eredeti adatkeret változója tud csak lenni, nem az első indexelésben már áttranszformálté! (Értelemszerűen, hiszen az nincs elmentve, nincs semmilyen külön neve, ahogy hivatkozhatnánk rá.) Ha csak legegyszerűbb transzformációt, sorok szűrését vesszük: RawDataDF[RawDataDF$Sex == \"Férfi\",][RawDataDF$Year == 2010,] nem fog működni, ez onnan kapásból látszik, hogy RawDataDF$Year == 2010 ugyanolyan hosszú, mint RawDataDF, viszont RawDataDF[RawDataDF$Sex == \"Férfi\",] már rövidebb, tehát ez így biztosan nem lehet jó, mert az adattáblát hosszabb vektorral próbáljuk indexelni, mint ahány sora van. Data frame használatával erre problémára nincs megoldás, hiszen RawDataDF[RawDataDF$Sex == \"Férfi\",] táblázat Year változójára nem tudunk sehogy sem hivatkozni második indexelésben, hiszen az nincs elmentve, nincs külön neve, amivel hivatkozhatnánk.data table esetében azonban, kihasználva, hogy változóra hivatkozhatunk csak nevével, táblázat neve nélkül, erre nagyon egyszerű megoldás: annyi feladat, hogy második indexben szereplő Year alatt data.table azt értse, hogy az első indexelés után kapott táblázat Year nevű változója (ne azt, hogy az eredetié). És így van megírva data.table, ezért szerepelt korábban az megfogalmazás, hogy második index az első indexeléssel már transzformált táblára vonatkozik. Így aztán következő hívás tökéletesen működik data table-lel:Ez még nem legátütőbb példa – bár sokszor az ilyenek nagyon jól jönnek – hiszen használhattunk volna egyszerűen & jelet és egyetlen indexelést. dolog igazi erejét az adja, hogy – ismét csak abból fakadóan, hogy második index már az elsőnek indexelt táblát látja, neki nem számít, hogy az nem egy lementett tábla, hanem egy már átalakított – módunk van menet közben létrehozott változókra hivatkozni! Például miután kiszámoltuk rák-típusonként az incidenciát, szeretnénk táblázatot az incidenciák szerint növekvő sorba rakni. Íme megoldás:Hiába nem létezik Inc nevű változó az eredeti adattáblában, ez hívás mégis tökéletesen fog működni! Megint csak: azért, mert második index már az első indexeléssel átalakított táblát kapja meg, és azt látja, pontosan ugyanúgy, mintha az egy lementett tábla lenne.","code":"\nRawData[Sex == \"Férfi\"][Year == 2010]## Key: <County, Sex, Age, Year>\n##               County    Sex   Age  Year ICDCode     N Population\n##               <char> <char> <num> <num>  <char> <int>      <num>\n##     1: Baranya megye  Férfi     0  2010     C00     0     9430.0\n##     2: Baranya megye  Férfi     0  2010     C01     0     9430.0\n##     3: Baranya megye  Férfi     0  2010     C02     0     9430.0\n##     4: Baranya megye  Férfi     0  2010     C03     0     9430.0\n##     5: Baranya megye  Férfi     0  2010     C04     0     9430.0\n##    ---                                                          \n## 34556:    Zala megye  Férfi    85  2010     D06     0     1447.5\n## 34557:    Zala megye  Férfi    85  2010     D07     0     1447.5\n## 34558:    Zala megye  Férfi    85  2010     D09     0     1447.5\n## 34559:    Zala megye  Férfi    85  2010     D30     0     1447.5\n## 34560:    Zala megye  Férfi    85  2010     D33     4     1447.5\nRawData[Age == 40 & County == \"Budapest\" & Sex == \"Férfi\",\n        .(Inc = sum(N) / sum(Population) * 1e5),\n        .(ICDCode)][order(Inc)]##     ICDCode         Inc\n##      <char>       <num>\n##  1:     C47  0.00000000\n##  2:     C51  0.00000000\n##  3:     C52  0.00000000\n##  4:     C53  0.00000000\n##  5:     C54  0.00000000\n##  6:     C55  0.00000000\n##  7:     C56  0.00000000\n##  8:     C57  0.00000000\n##  9:     C58  0.00000000\n## 10:     C66  0.00000000\n## 11:     C88  0.00000000\n## 12:     C93  0.00000000\n## 13:     C97  0.00000000\n## 14:     D05  0.00000000\n## 15:     D06  0.00000000\n## 16:     C33  0.09216118\n## 17:     C95  0.09216118\n## 18:     D02  0.09216118\n## 19:     C68  0.18432237\n## 20:     C94  0.18432237\n## 21:     D01  0.18432237\n## 22:     C65  0.27648355\n## 23:     C75  0.27648355\n## 24:     D09  0.27648355\n## 25:     C00  0.36864474\n## 26:     C39  0.36864474\n## 27:     D07  0.36864474\n## 28:     C12  0.46080592\n## 29:     C26  0.46080592\n## 30:     C37  0.46080592\n## 31:     C46  0.46080592\n## 32:     D00  0.46080592\n## 33:     C06  0.55296711\n## 34:     C21  0.55296711\n## 35:     C70  0.55296711\n## 36:     C30  0.64512829\n## 37:     C45  0.64512829\n## 38:     C63  0.64512829\n## 39:     C05  0.73728948\n## 40:     C08  0.73728948\n## 41:     C74  0.73728948\n## 42:     C14  0.82945066\n## 43:     C07  0.92161184\n## 44:     C60  0.92161184\n## 45:     C84  0.92161184\n## 46:     C03  1.01377303\n## 47:     C23  1.01377303\n## 48:     C40  1.01377303\n## 49:     C31  1.10593421\n## 50:     C38  1.10593421\n## 51:     C69  1.10593421\n## 52:     C72  1.10593421\n## 53:     C11  1.19809540\n## 54:     D30  1.38241777\n## 55:     C24  1.47457895\n## 56:     C96  1.56674013\n## 57:     C09  1.65890132\n## 58:     C17  1.75106250\n## 59:     D04  1.75106250\n## 60:     C01  2.21186843\n## 61:     C90  2.21186843\n## 62:     C48  2.39619079\n## 63:     C80  2.39619079\n## 64:     C04  2.48835198\n## 65:     C02  2.58051316\n## 66:     C19  2.58051316\n## 67:     C82  2.58051316\n## 68:     C76  2.67267435\n## 69:     C50  2.76483553\n## 70:     C41  2.94915790\n## 71:     C61  2.94915790\n## 72:     C10  3.13348027\n## 73:     C91  3.31780264\n## 74:     C81  3.40996382\n## 75:     C22  3.87076974\n## 76:     C83  3.96293093\n## 77:     C15  4.14725330\n## 78:     C13  4.42373685\n## 79:     C85  4.42373685\n## 80:     C92  4.51589803\n## 81:     D03  4.60805922\n## 82:     C73  5.06886514\n## 83:     D33  6.26696054\n## 84:     C16  6.72776646\n## 85:     C20  7.09641120\n## 86:     C25  7.37289475\n## 87:     C32  7.46505593\n## 88:     C67  8.38666778\n## 89:     C71  8.75531252\n## 90:     C49 10.78285857\n## 91:     C18 11.15150331\n## 92:     C64 12.25743752\n## 93:     C43 17.41846385\n## 94:     C62 22.11868425\n## 95:     C34 30.78183558\n## 96:     C44 43.13143429\n##     ICDCode         Inc"},{"path":"data-table-egy-továbbfejlesztett-adatkeret.html","id":"referencia-szemantika","chapter":"6 . fejezet Data table: egy továbbfejlesztett adatkeret","heading":"6.7 Referencia szemantika","text":"data.table bevezet egy új megközelítést arra, hogy új változót definiáljunk egy táblában – ám hamar ki fog derülni, hogy itt jóval többről van szó, mint egyszerűen egy alternatív jelölésről.Például számoljuk ki, és ezúttal táblázatban tároljuk el az incidenciákat15:data.table által bevezett új megoldás esetén az értékadás jele :=, de ami talán még fontosabb, hogy ezt, elsőre elég meglepő módon, úgy kell megadni, mintha indexelnénk, tehát szögleges zárójelek között! második pozícióba, az oszlopindex helyébe kell kerüljön:kettő valóban ugyanazt eredményezi:Ebben van egy újdonság: az összes eddigi példában új táblát hoztunk létre (még ha csak ki írattuk, és nem mentettük el változóba), ez az első eset, ahol meglevő táblát módosítunk. Ez nagyon fontos: mint láthatjuk , nem kell az eredményt belementenünk egy változóba, azért nem, mert az utasítás lefuttatásakor maga az eredeti tábla módosult! Ezt szokták az informatikában referencia szerinti módosításnak16 hívni. (És igen, ezt az indexelés szintaktikájával éri el data.table, még ha elég meglepő első látásra.)Kiíratás ilyenkor ugyanúgy nincs, mint általában az értékadásos utasításoknál R-ben. Ha szeretnénk az értékadás után rögtön ki íratni táblát akkor egy [] jelet kell tennünk parancs után, pl. RawData[, Inc2 := N / Population * 1e5][].Használhatjuk ezt megoldást meglevő változó felülírására, nem csak új létrehozására. Például, ha meggondoljuk magunkat, és az incidenciát per millió fő mértékegységben szeretnénk megadni:Egyszerre több változót definiálhatunk (lehet vegyesen új definiálása és régi felülírása, ennek nincs jelentősége), ennek módszere:Mivel az értékadás bal oldalán sztring-vektor áll, így könnyen előállítható gépi úton . jobb oldalon pedig lista szerepel, így itt igaz, hogy nem muszáj kézzel felsorolni, bármilyen olyan függvény szerepelhet ott, ami listát ad vissza.Változó törölhető ilyen módon:Ha több változót törölnénk:Mi értelme van mindennek? Az első válasz az, hogy bizonyos esetekben gyorsabb17. második, hogy mindez kombinálható data.table többi elemével, tehát sorindexeléssel és csoportosítással.Például szeretnénk Budapest kifejezést lecserélni arra, hogy Főváros megye változóban. Ezt megoldhatjuk így:Tehát: ha az értékadást szűréssel kombináljuk, akkor nem kiválasztott soroknál nem változik az érték. (Ha pedig nem meglevő változót módosítunk, hanem újat hozunk létre, akkor nem kiválasztott soroknál NA kerül az új változóba.)Ezt könnyen megoldhattuk volna másképp , de nézzük egy izgalmasabb példát. Szeretnénk minden nemre, életkorra, megyére és ráktípusra eltárolni, hogy az adott nemből, életkorból, megyéből és ráktípusból mi volt legkisebb feljegyzett incidencia (különböző évek közül, tehát). Ezt data.table nélkül csak macerásabban tudnánk megtenni, de data.table használatával nagyon egyszerű (és nagyon logikus) megoldás:csoportosító változót kell használnunk, ami teljesen logikus : képezi csoportokat nem, életkor, megye és ráktípus szerint (tehát az egyes csoportokban különböz évek fognak szerepelni), veszi azok körében az Inc minimumát, és azt menti el MinInc néven – az adott csoport különböző soraihoz mindig ugyanazt az értéket. Íme:","code":"\nRawData$Inc <- RawData$N / RawData$Population * 1e5\nRawData[, Inc2 := N / Population * 1e5]\nidentical(RawData$Inc, RawData$Inc2)## [1] TRUE\nRawData[, Inc2 := Inc2 * 10]\nRawData[, c(\"logPop\", \"sqrtPop\") := list(log(Population),\n                                         sqrt(Population))]\nRawData[, Inc2 := NULL]\nRawData[, c(\"logPop\", \"sqrtPop\") := NULL]\nRawData[County == \"Budapest\", County := \"Főváros\"]\nRawData[, MinInc := min(Inc), .(County, Sex, Age, ICDCode)]\nRawData[ICDCode == \"C18\" & Age == 70 & County == \"Főváros\"]##      County    Sex   Age  Year ICDCode     N Population      Inc   MinInc\n##      <char> <char> <num> <num>  <char> <int>      <num>    <num>    <num>\n##  1: Főváros  Férfi    70  2000     C18    97    30697.5 315.9866 217.0223\n##  2: Főváros  Férfi    70  2001     C18   111    32326.5 343.3715 217.0223\n##  3: Főváros  Férfi    70  2002     C18   108    31711.5 340.5705 217.0223\n##  4: Főváros  Férfi    70  2003     C18    99    30984.0 319.5198 217.0223\n##  5: Főváros  Férfi    70  2004     C18   100    30205.5 331.0655 217.0223\n##  6: Főváros  Férfi    70  2005     C18    97    29194.5 332.2544 217.0223\n##  7: Főváros  Férfi    70  2006     C18    90    28123.5 320.0171 217.0223\n##  8: Főváros  Férfi    70  2007     C18    96    27422.5 350.0775 217.0223\n##  9: Főváros  Férfi    70  2008     C18    95    27080.5 350.8059 217.0223\n## 10: Főváros  Férfi    70  2009     C18   102    26957.0 378.3804 217.0223\n## 11: Főváros  Férfi    70  2010     C18    80    27335.5 292.6597 217.0223\n## 12: Főváros  Férfi    70  2011     C18    97    28288.0 342.9016 217.0223\n## 13: Főváros  Férfi    70  2012     C18    89    30601.5 290.8354 217.0223\n## 14: Főváros  Férfi    70  2013     C18   118    32451.0 363.6252 217.0223\n## 15: Főváros  Férfi    70  2014     C18   108    34269.5 315.1490 217.0223\n## 16: Főváros  Férfi    70  2015     C18   103    35428.0 290.7305 217.0223\n## 17: Főváros  Férfi    70  2016     C18   107    35831.5 298.6199 217.0223\n## 18: Főváros  Férfi    70  2017     C18   101    36012.0 280.4621 217.0223\n## 19: Főváros  Férfi    70  2018     C18    78    35941.0 217.0223 217.0223\n## 20: Főváros     Nő    70  2000     C18   115    52434.0 219.3233 161.1007\n## 21: Főváros     Nő    70  2001     C18    99    53138.5 186.3056 161.1007\n## 22: Főváros     Nő    70  2002     C18    95    51751.0 183.5713 161.1007\n## 23: Főváros     Nő    70  2003     C18   110    50498.5 217.8283 161.1007\n## 24: Főváros     Nő    70  2004     C18    92    49073.0 187.4758 161.1007\n## 25: Főváros     Nő    70  2005     C18   102    47308.5 215.6061 161.1007\n## 26: Főváros     Nő    70  2006     C18    74    45934.0 161.1007 161.1007\n## 27: Főváros     Nő    70  2007     C18    95    45165.0 210.3399 161.1007\n## 28: Főváros     Nő    70  2008     C18    94    44594.5 210.7883 161.1007\n## 29: Főváros     Nő    70  2009     C18    84    44558.5 188.5162 161.1007\n## 30: Főváros     Nő    70  2010     C18    81    45258.5 178.9719 161.1007\n## 31: Főváros     Nő    70  2011     C18   101    46479.0 217.3024 161.1007\n## 32: Főváros     Nő    70  2012     C18   104    48132.0 216.0725 161.1007\n## 33: Főváros     Nő    70  2013     C18   134    50451.0 265.6042 161.1007\n## 34: Főváros     Nő    70  2014     C18   124    52854.0 234.6085 161.1007\n## 35: Főváros     Nő    70  2015     C18    94    54534.5 172.3680 161.1007\n## 36: Főváros     Nő    70  2016     C18   120    55317.5 216.9295 161.1007\n## 37: Főváros     Nő    70  2017     C18    95    55986.5 169.6838 161.1007\n## 38: Főváros     Nő    70  2018     C18   113    56508.0 199.9717 161.1007\n##      County    Sex   Age  Year ICDCode     N Population      Inc   MinInc"}]
